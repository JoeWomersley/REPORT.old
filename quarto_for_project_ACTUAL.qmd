---
title: "Data Analysis Of Haemapoetic Stem Cell Linages"
author: "Joseph Womersley"
engine: knitr
execute:
  echo: false
  include: true
  error: false
  message: false
  warning: false
format: html
editor: visual
bibliography: references.bib
---

```{=html}

<style>
  figure {
    margin-bottom: 0px !important; /* Reduce space below figure */
    overflow: visible !important;
  }
  figcaption {
    margin-top: -5px !important; /* Reduce space above caption */
    margin-bottom: 10px !important; /* Reduce space below caption */
  }
  figure, figcaption {
    padding: 0 !important;
    height: auto !important;
    max-height: none !important;
    overflow: visible !important;
  }
  img, figure {
  max-width: 100% !important;
  width: auto !important;
  height: auto !important;
}
</style>
```
```{css}

/* CSS chunk to style the rendered datatable */
.dataTables_wrapper {
  font-size: 13px; /* Adjust the font size as needed */
  font-family: Arial, sans-serif; /* Specify the font family */
}

```

```{r}
#| label: packages
#| include: false
library(tidyverse)
library(patchwork)
library(htmlTable)
library(DT)
library(conflicted)
conflict_prefer("filter", "dplyr")
conflict_prefer("setdiff", "base")
library(scran)
library(biomaRt)
conflicts_prefer(dplyr::select)
library(bookdown)
library(knitr)
library(kableExtra)
library(ggrepel)
library(pheatmap)
library(plotly)
library(readxl)
conflicts_prefer(plotly::layout)
conflicts_prefer(plotly::slice)
```

# Introduction

Hematopoietic stem cells (HSCs) are at the apex of the differentiation hierarchy and defined by their ability to differentiate and produces the full spectrum of mature blood cells via intermediate progenitor stages as well as self-renew to sustain haematopoiesis. Long-term hematopoietic stem cells (LT.HSCs) sit within this HSC pool and are of much interest due to their capacity to support long-term hematopoietic reconstitution meaning they are capable of repopulating the bone marrow in functional transplantation assays, which requires high self-renewal ability, developmental potential and homing[@gur-cohen2016; @notta2011]. The extensive regenerative potential of LT.HSCs makes them attractive targets as achieving efficient and controlled invitro HSC expansion and defined mature cell production would have substantial therapeutic implications. Utilising surface markers for these cells has allowed for HSC purities of more than 50%. However, none have allowed for populations of a single homogeneous cell type [@adam2005; @kent2009; @zhang2005; @nestorowa2016]. Recently there has been the development of single-cell profiling techniques which are able to profile transitional cells and resolve the heterogeneity within these populations' at large numbers [@bendall2014; @jaitin2014; @mahata2014]. This should allow the identification of novel HSC markers, allowing for a deeper insight into human HSC biology and facilitate further purification of HSCs for clinical applications discussed earlier [@nestorowa2016]. We utilised single cell RNA-sequencing data collected by [@nestorowa2016] which analysed over 1600 single HSPC transcriptomes which were profiled into LT-HSCs, HSPCs and Progenitor cells using FACS index sorting and using wide gating to allow for analysis of transitional cells. This allowec us to find a new marker of LT.HSCs.

# Methods

## Data Description

The data files used in this report: [surfaceome_hspc.csv](https://joewomersley.github.io/report_quarto/hspc_surfaceome.html), [surfaceome_lthsc.csv](https://joewomersley.github.io/report_quarto/lthsc_surfaceome.html), [surfaceome_prog.csv](https://joewomersley.github.io/report_quarto/prog_surfaceome.html), [er_cell_types.csv](https://joewomersley.github.io/report_quarto/er_cell_types.html) and [qPCR_raw_data.xlsx](https://joewomersley.github.io/report_quarto/qPCR_raw_data.html)

The surfaceosome data contains Log~2~ absolute expression values. Each row is a gene represented by its ensembl gene id. Also in the files are columns for each specific cell labelled numerically.

The data in er_cell_types.csv redefines the previous cell type definitions. each row is an old cell definition for all of the three cell types. Each column represents a new cell type definition whereby going down the column a 1 indicates that new cell definition can be used to re-define the old cell type, a 0 indicates it does not.

The data in qPCR_raw_data contains relative abundance values of the Mmrn1 gene. Each row is a cell and its relative abundance with the columns being the cell_type and then Mmrn1 mean expression. Whereby the mean expression is calculated by using expression of Mmrn1 done in triplicate and normalised against HPRT to determine its relative abundance.

## Data Preparation

I used R (R Core Team 2021) with.**`tidyverse`**.packages [@wickham2019] to import and process the raw data. Differential expression analysis was then performed to determine the log fold change between cell types. We used the .**`findmarkers()`**. function to run this differential analysis within the .**`scran`**. package [@lun2016] which also employs statistical testing upon the analysis to generate p.values and false discover rate.

## Visualisation Through Mean Expression Plots With Error Bars And Histograms

mean expression plots with error bars and histograms were used to visualise the gene expression across the cells and genes to ensure they are similar across the cell types and also to ensure that there were minimal outliers as well as understand more the distribution in expression. The .**`tidyverse`**.packages [@wickham2019] were used to generate the plots.

## Volcano Plots

volcano plots We then used to visualise the differential analysis through using the .**`ggplot2`**. package [@ggplot2] whereby we coloured points with  q \< 0.05 where q is the False Discovery Rate (FDR) adjusted p-value. FDR is a method of correcting for multiple comparisons by the Benjamini--Hochberg procedure [@benjamini1995]. Additionally, we labelled points with there corresponding gene name, when their Log fold change was greater than 2.5. We did this using the .**`BiomaRt`**. package [@biomaRt] and created a logical variable .**`bigfc`**. which represents whether the absolute value of the log fold change for a particular gene exceeds 2.5 and used the .**`ggrepel`**. package to avoid labels overlapping.

## Bar Plots

All bar plots were produced using .**`tidyverse`**.packages [@wickham2019], specifically the .**`ggplot2`**. package [@ggplot2]. Whereby all bars have there standard error also visualised, Error bars are x¯±1s.e. where s.e. is the standard error of the mean. P values: *\*, P \< 0.05; \*\**, P \< 0.01; \*\*\*, P \< 0.001; \*\*\*\*, P \< 0.0001.

## Tables

Tables were generated to show genes differentially expressed genes (logFC \> 1) for each of the three comparisons, both with and without duplicate genes showing different comparisons. The .**`htmlTable`**. package [@htmlTable] was used to generate the tables and the .**`DT`**. package [@DT] was used to format the tables, allowing them to be interactive.

## Visualisation With Principal Components Analysis

Dimensionality-reduction was performed on the Log~2~-transposed absolute expression data of the 280 genes by using principle component analysis. The Package .**`Plotly`**. [@plotly] was used to visualise the first 3 principle components, generating a three-dimensional PCA plots.

## Heatmaps And Clustering

hierarchical clustering was performed and heatmaps produced with the package .**`Pheatmap`**. [@pheatmap] with .**`BiomaRt`**. [@biomaRt] used to convert the ensembl gene ids to gene symbols. Hierarchical clustering used the Ward.D2 method and was performed for both genes and cells. For both heatmaps where heirchical clustering was perormed only the Top 50 significantly differentially expressed genes we visualised. Genes were deemed significantly deferentially expressed when LogFC \> 1, which left 101 genes, we took the top 50 of these genes and deemed them significant by  q \< 0.01.

# Results

firstly we analysed our primary data; [HSPC](https://joewomersley.github.io/report_quarto/hspc_surfaceome.html), [LT.HSC](https://joewomersley.github.io/report_quarto/lthsc_surfaceome.html), [Progenitor](https://joewomersley.github.io/report_quarto/prog_surfaceome.html). we did this to determine if the data needed to be filtered and determine if here were any difference in gene expression across the three cell types. To be able to determine this we visualised the data through a histogram showing the expression of the 280 genes. see @fig-panel-histogram. Notably, there is a bimodal appearance, which is likely due to the subset of genes consisting of cell surface proteins which show differences between the cell subtypes within the wider cell types shown and an excess of expression values less below one, which we. might consider removing. The histograms were generated utilising the same techniques used by [@rand2023].

```{r}
# first i am loading in my raw data files 
hspc <- read.csv("data_raw/surfaceome_hspc.csv")
prog <- read.csv("data_raw/surfaceome_prog.csv")
lthsc <- read.csv("data_raw/surfaceome_lthsc.csv")

#i am writing as a html to be uploaded to github so a URL can be made so the reader of the html output can see the raw data files 

# Create interactive DT tables for each dataset
dt_prog_raw <- datatable(prog, options = list(pageLength = 10, searchHighlight = TRUE))
dt_hspc_raw <- datatable(hspc, options = list(pageLength = 10, searchHighlight = TRUE))
dt_lthsc_raw <- datatable(lthsc, options = list(pageLength = 10, searchHighlight = TRUE))

# Save the DT tables as HTML files
saveWidget(dt_prog_raw, "data_raw/HTML/surfaceome_prog.html", selfcontained = TRUE)
saveWidget(dt_hspc_raw, "data_raw/HTML/surfaceome_hspc.html", selfcontained = TRUE)
saveWidget(dt_lthsc_raw, "data_raw/HTML/surfaceome_lthsc.html", selfcontained = TRUE)

# it comes up with a warning for the tables indicating they are too large but when inspecting them, the tables seem to be complete. For larger data sets one will likely not be able to use datatables. 
```

```{r}

# here i am pivoting the expression values so all the counts are in a single column (expr). 
lthsc_long <- lthsc |> 
  pivot_longer(cols = -ensembl_gene_id,
               names_to = "cell",
               values_to = "expression")

# By pivoting the data we are now able to direct that int a ggplot to create a histogram which allows the datas visualisation to see if there are differences in gene expression across the three cell types. 
lthsc_histogram <- ggplot(lthsc_long, aes(x = expression)) +
  geom_histogram(fill = "green", color = "black", binwidth = 0.5) +
  theme_minimal() + 
  labs(title = "LT.HSC") +
  theme(panel.grid = element_blank(),  # Remove grid lines
        axis.line.x = element_line(color = "black", linewidth = 1),  # Adjust x-axis line
        axis.line.y = element_line(color = "black", linewidth = 1),
        axis.text = element_text(size = 30), 
        axis.title = element_text(size = 35),  # Increase axis title size
        axis.line = element_line(size = 2),  # Make axis lines thicker
        plot.title = element_text(size = 40, hjust = 0.5, colour = 'green3', face = "bold"))  # Adjust plot margins to move it downwards slightly

# Save the plot
ggsave("figures/lthsc_histogram.png", plot = lthsc_histogram, width = 10, height = 6, dpi = 300)
```

```{r}
# Here i am going the same process but for the hspc raw data 

hspc_long <- hspc |> 
  pivot_longer(cols = -ensembl_gene_id,
               names_to = "cell",
               values_to = "expression")



hspc_histogram <- ggplot(hspc_long, aes(x = expression)) +
  geom_histogram(fill = "red", color = "black", binwidth = 0.5) +
  theme_minimal() +
  labs(title = "HSPC") +
  theme(panel.grid = element_blank(),  # Remove grid lines
        axis.line.x = element_line(color = "black", size = 1),  # Adjust x-axis line
        axis.line.y = element_line(color = "black", size = 1),
        axis.text = element_text(size = 30),  # Increase axis text size
        axis.title = element_text(size = 35),  # Increase axis title size
        axis.line = element_line(size = 2),  # Make axis lines thicker
        plot.title = element_text(size = 40, hjust = 0.5,  colour = 'red', face = "bold"))

# Save the plot
ggsave("figures/hspc_histogram.png", plot = hspc_histogram, width = 10, height = 6, dpi = 300)
```

```{r}
#here i am doing the same thing but for the progenitor raw data

prog_long <- prog |> 
  pivot_longer(cols = -ensembl_gene_id,
               names_to = "cell",
               values_to = "expression")



prog_histogram <- ggplot(prog_long, aes(x = expression)) +
  geom_histogram(fill = "blue", color = "black", binwidth = 0.5) +
  theme_minimal() +
    labs(title = "Prog") +
  theme(panel.grid.major = element_blank(),  # Remove major grid lines
        panel.grid.minor = element_blank(),  # Remove minor grid lines
        axis.line.x = element_line(color = "black", size = 1),  # Adjust x-axis line
        axis.line.y = element_line(color = "black", size = 1),
        axis.text = element_text(size = 30), # Increase axis text size
        axis.title = element_text(size = 35), axis.line = element_line(size = 2), 
        plot.title = element_text(size = 40, hjust = 0.5,  colour = 'blue', face = "bold")) + scale_y_continuous(limits = c(0, 114300)) # Adjust y-axis line

# Save the plot
ggsave("figures/prog_histogram.png", plot = prog_histogram, width = 10, height = 6, dpi = 300)
```

```{r}
#| label: fig-panel-histogram
#| fig.cap: "Histogram of Gene Expression Distribution Across Samples. Each histogram represents a different cell type expression derived from single-cell RNA sequencing data. Each bar in the histogram corresponds to a range of expression levels, with the x-axis representing the log2 absolute expression of the surfaceome genes, and the y-axis representing the count of cells falling within each expression range. Data analysis as conducted in R (R Core Team 2023) with patchwork, tidyverse packages (Pedersen et al. 2023; Wickham et al. 2019) "
#| fig.align: "right"
#| fig.width: 25
#| fig.height: 7

# to allow for easy comparision of the histograms we made earlier we are rendering them next to one another. 

# here we are grouping the hspc_histogram, prog_histogram and lthsc_histogram into a panel and specificying the margin of the plot which is used in this case to allow for sufficient space under the histograms before the figure legend. An issue i came across was the figure legend rednering underneath the histograms and specifcying the margins solved this issue. 
panel_histogram <- hspc_histogram + prog_histogram + lthsc_histogram + 
  plot_layout(guides = 'collect') & 
  theme(plot.margin = margin(t = 0.4, r = 0.1, b = 0.4, l = 0.4, unit = "cm"))

# This code adjusts the layout of the histograms as they can render portrait or landscape. Iwanted the histograms to all be next to one another so i specified ncols being 3 if you wanted one under the other you could specificy nol = 1. the heights is again to ensure that when they redner the graphs are the correct height as without specifcying this th histograms appeared squished. 
panel_histogram <- panel_histogram + 
  plot_layout(ncol = 3, heights = c(40, 2, 2)) # Adjust 'ncol' and 'heights' as needed

panel_histogram
```

additionally we inspected the direct variability of gene expression across the cells within each cell type. we firstly determined the min, lowerq, mean, median, sd, upperq, max and n_zero expression of the genes in each cell for the 3 cell types; [HSPC](https://joewomersley.github.io/report_quarto/hspc_summary_samp.html), [LT.HSC](https://joewomersley.github.io/report_quarto/lthsc_summary_samp.html), [Prog](https://joewomersley.github.io/report_quarto/prog_summary_samp.html), by utilising the same techniques used by [@rand2023]. We then visualised this analysis by ordering the cells based on mean expression. Additionally, we added in error bars extending from each point to show the range of expression values within that cell, within one standard deviation. see @fig-panel-point-error-plot. This showed that the average gene expression across the cells and indeed the cell types indicating no cells need to be removed from the data set due to much lower expression which would indicate their sequencing might have been defective. additionally, the distribution of expression between the cell types seems to be similar with no large differences in gene expression. notably, approximately every cell in each cell types have the lower quartile of their expression as zero, meaning every cell has some genes with no expression showing that each cell will likely have a gene expression profile with big differences in gene expression.

```{r}
# here we are determining the min, lowerq, mean, median, sd, upperq, max and n_zero expression of the genes in each cell: 
hspc_summary_samp <- hspc |>
  pivot_longer(cols = -ensembl_gene_id,
               names_to = "cell",
               values_to = "expr") |>
  group_by(cell) |>
  summarise(min = min(expr),
            lowerq = quantile(expr, 0.25),
            mean = mean(expr),
            median = median(expr),
            sd = sd(expr),
            upperq = quantile(expr, 0.75),
            max = max(expr),
            n_zero = sum(expr == 0))

# so here we are visulaising the data we have collected above by generating a plot that maps the average expression across the cells with them being in order from lowest to highest gene expression and we added in error bars extending from each point to show the range of expression values within that cell, within one standard deviation. 

hspc_point_error_plot <- hspc_summary_samp |> 
  ggplot(aes(x = reorder(cell, mean), y = mean)) +
  # Drawing the error bars
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd),
                width = 0.2,  # Adjust the width of the error bars here
                linewidth = 0.5,  # Adjust the thickness of the error bars here
                color = "red") +  # This sets the color of the error bars 
  # Drawing the points
  geom_point(size = 0.5,  # Adjust the size of the points here
             color = "darkred") +  # This sets the color of the dots independently
  theme_minimal() +
  theme(axis.line.x = element_line(color = "black", size = 1),
        axis.line.y = element_line(color = "black", size = 1),
        axis.text = element_text(size = 30),  # Adjusted for visibility
        axis.title = element_text(size = 35),  # Adjusted for visibility
        axis.line = element_line(size = 2),
        axis.text.x = element_blank(),
  plot.title = element_text(size = 40, hjust = 0.5,  colour = 'red', face = "bold")) +
  labs(x = "Cells reordered", y = "Mean Expression", title = "HSPC")

# Save the plot
ggsave("figures/hspc_point_error_plot.png", plot = hspc_point_error_plot, width = 10, height = 6, dpi = 300)
```

```{r}
# Here i am doing the same thing but with the lthsc data set 

lthsc_summary_samp <- lthsc |>
  pivot_longer(cols = -ensembl_gene_id,
               names_to = "cell",
               values_to = "expr") |>
  group_by(cell) |>
  summarise(min = min(expr),
            lowerq = quantile(expr, 0.25),
            mean = mean(expr),
            median = median(expr),
            sd = sd(expr),
            upperq = quantile(expr, 0.75),
            max = max(expr),
            n_zero = sum(expr == 0))


lthsc_point_error_plot <- lthsc_summary_samp |> 
  ggplot(aes(x = reorder(cell, mean), y = mean)) +
  # Drawing the error bars
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd),
                width = 0.2,  # Adjust the width of the error bars here
                linewidth = 0.5,  # Adjust the thickness of the error bars here
                color = "green") +  # This sets the color of the error bars 
  # Drawing the points
  geom_point(size = 1,  # Adjust the size of the points here
             color = "darkgreen") +  # This sets the color of the dots independently
  theme_minimal() +
  theme(axis.line.x = element_line(color = "black", size = 1),
        axis.line.y = element_line(color = "black", size = 1),
        axis.text = element_text(size = 30),  # Adjusted for visibility
        axis.title = element_text(size = 35),  # Adjusted for visibility
        axis.line = element_line(size = 2),
        axis.text.x = element_blank(),
        plot.title = element_text(size = 40, hjust = 0.5,  colour = 'green3', face = "bold")) +
  labs(x = "Cells reordered", y = "Mean Expression", title = "LT.HSC")

# Save the plot
ggsave("figures/lthsc_point_error_plot.png", plot = lthsc_point_error_plot, width = 10, height = 6, dpi = 300)
```

```{r}
# Here i am doing the same thing but with the lthsc data set 

prog_summary_samp <- prog |>
  pivot_longer(cols = -ensembl_gene_id,
               names_to = "cell",
               values_to = "expr") |>
  group_by(cell) |>
  summarise(min = min(expr),
            lowerq = quantile(expr, 0.25),
            mean = mean(expr),
            median = median(expr),
            sd = sd(expr),
            upperq = quantile(expr, 0.75),
            max = max(expr),
            n_zero = sum(expr == 0))

prog_point_error_plot <- prog_summary_samp |> 
  ggplot(aes(x = reorder(cell, mean), y = mean)) +
  # Drawing the error bars
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd),
                width = 0.2,  # Adjust the width of the error bars here
                linewidth = 0.5,  # Adjust the thickness of the error bars here
                color = "blue") +  # This sets the color of the error bars to blue
  # Drawing the points
  geom_point(size = 0.5,  # Adjust the size of the points here
             color = "darkblue") +  # This sets the color of the dots independently
  theme_minimal() +
  theme(axis.line.x = element_line(color = "black", size = 1),
        axis.line.y = element_line(color = "black", size = 1),
        axis.text = element_text(size = 30),  # Adjusted for visibility
        axis.title = element_text(size = 35),  # Adjusted for visibility
        axis.line = element_line(size = 2),
        axis.text.x = element_blank(),
        plot.title = element_text(size = 40, hjust = 0.5,  colour = 'blue', face = "bold")) +
  labs(x = "Cells reordered", y = "Mean Expression", title = "Prog")

# Save the plot
ggsave("figures/prog_point_error_plot.png", plot = prog_point_error_plot, width = 10, height = 6, dpi = 300)
```

```{r}
#| label: fig-panel-point-error-plot
#| fig.cap: "The Variability In Gene Expression Across Cell Types. Each figure above represents the distribution of gene expression across the 3 cell types derived from the single cell RNA sequencing data with cells ordered corresponding their mean expression along the X axis and mean expression along the Y axis. Each dot represents the mean expression level of each cell, the error bars extending from each point show the range of expression values within that cell within one standard deviation. Data analysis as conducted in R (R Core Team 2023) with patchwork, tidyverse packages (Pedersen et al. 2023; Wickham et al. 2019)"
#| fig.align: "right"
#| fig.width: 25
#| fig.height: 7

# again we are utilising the patchwork package to combine the plots 
panel_point_error_plot <- prog_point_error_plot + lthsc_point_error_plot + hspc_point_error_plot + 
  plot_layout(guides = 'collect') 

# Again like with the histogram panel we are specifying that the graphs be ordered next to each other and specificy the height of the panel 
panel_point_error_plot <- panel_point_error_plot + 
  plot_layout(ncol = 3, heights = c(40, 2, 2)) # Adjust 'ncol' and 'heights' as needed

panel_point_error_plot
```

```{r}
# here i am just writing csv files of the data we processed and analysed. 
write_csv(prog_summary_samp, "processed_data/prog_summary_samp.csv")
write_csv(lthsc_summary_samp, "processed_data/lthsc_summary_samp.csv")
write_csv(hspc_summary_samp, "processed_data/hspc_summary_samp.csv")
```

```{r}
# here we are writing the data as a html to be uploaded to github so a URL can be made so the reader of the output can see the file. 

# first we manipulated the daa to become interactive DT tables. 
dt_prog <- datatable(prog_summary_samp, options = list(pageLength = 10, searchHighlight = TRUE))
dt_hspc <- datatable(hspc_summary_samp, options = list(pageLength = 10, searchHighlight = TRUE))
dt_lthsc <- datatable(lthsc_summary_samp, options = list(pageLength = 10, searchHighlight = TRUE))

# Save the DT tables as HTML files
saveWidget(dt_prog, "processed_data/HTML/prog_summary_samp.html", selfcontained = TRUE)
saveWidget(dt_hspc, "processed_data/HTML/hspc_summary_samp.html", selfcontained = TRUE)
saveWidget(dt_lthsc, "processed_data/HTML/lthsc_summary_samp.html", selfcontained = TRUE)
```

Then we wanted to determine the distribution of expression of the genes across the genes. again we determined the min, lowerq, mean, median, sd, upperq, max and n_zero expression of the genes, but not in each cell, rather in each gene for the 3 cell types; [HSPC](https://joewomersley.github.io/report_quarto/hspc_summary_gene.html), [LT.HSC](https://joewomersley.github.io/report_quarto/lthsc_summary_gene.html), [Prog](https://joewomersley.github.io/report_quarto/prog_summary_gene.html), again by utilising the same techniques used by [@rand2023]. Then we visualised by ordering each genes mean expression. see @fig-panel-point-error-plot-gene. This showed a massive variability between genes, much greater than between cells. still however there is no gene that has no expression in no cells, which might indicate they should be removed from the data set, and the range of expression is quite similar across the three cell types.

```{r}
# here we are determining the min, lowerq, mean, median, sd, upperq, max and n_zero expression of the cells in each gene utilising the same technique seen above: 
prog_summary_gene <- prog |>
  pivot_longer(cols = -ensembl_gene_id,
               names_to = "cell",
               values_to = "expr") |>
  group_by(ensembl_gene_id) |>
  summarise(min = min(expr),
            lowerq = quantile(expr, 0.25),
            sd = sd(expr),
            mean = mean(expr),
            median = median(expr),
            upperq = quantile(expr, 0.75),
            max = max(expr),
            total = sum(expr),
            n_zero = sum(expr == 0))

# here we are plotting the logged mean counts for each gene in order of size using geom_pointrange() and again ordering the genes from lowest to highest gene expression and we added in error bars extending from each point to show the range of expression values within that gene, within one standard deviation. 

prog_point_error_plot_gene <- prog_summary_gene |> 
  ggplot(aes(x = reorder(ensembl_gene_id, mean), y = mean)) +
  geom_pointrange(aes(ymin = mean - sd, ymax = mean + sd, color = "blue"),
                  size = 0.1) +
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd, color = "darkblue"),
                width = 0.1) +
  theme_minimal() +
  theme(axis.line.x = element_line(color = "black", size = 1),  # Adjust x-axis line
        axis.line.y = element_line(color = "black", size = 1),
        axis.text = element_text(size = 30),  # Increase axis text size
        axis.title = element_text(size = 35),  # Increase axis title size
        axis.line = element_line(size = 2), 
        axis.text.x = element_blank(), 
        plot.title = element_text(size = 40, hjust = 0.5,  colour = 'blue', face = "bold")) +
  labs(x = "genes", y = "Log Mean Expression", title = "prog") +
  scale_color_identity()

# Save the plot
ggsave("figures/prog_point_error_plot_gene.png", plot = prog_point_error_plot_gene, width = 10, height = 6, dpi = 300)
```

```{r}
# Here i am doing the same thing but with the hspc data set 

hspc_summary_gene <- hspc |>
  pivot_longer(cols = -ensembl_gene_id,
               names_to = "cell",
               values_to = "expr") |>
  group_by(ensembl_gene_id) |>
  summarise(min = min(expr),
            lowerq = quantile(expr, 0.25),
            sd = sd(expr),
            mean = mean(expr),
            median = median(expr),
            upperq = quantile(expr, 0.75),
            max = max(expr),
            total = sum(expr),
            n_zero = sum(expr == 0))

hspc_point_error_plot_gene <- hspc_summary_gene |> 
  ggplot(aes(x = reorder(ensembl_gene_id, mean), y = mean)) +
  geom_pointrange(aes(ymin = mean - sd, ymax = mean + sd, color = "red"),
                  size = 0.1) +
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd, color = "darkred"),
                width = 0.1) +
  theme_minimal() +
  theme(axis.line.x = element_line(color = "black", size = 1),  # Adjust x-axis line
        axis.line.y = element_line(color = "black", size = 1),
        axis.text = element_text(size = 30),  # Increase axis text size
        axis.title = element_text(size = 35),  # Increase axis title size
        axis.line = element_line(size = 2), 
        axis.text.x = element_blank(),
        plot.title = element_text(size = 40, hjust = 0.5,  colour = 'red', face = "bold")) +
  labs(x = "genes", y = "Mean Expression", title = "HSPC") +
  scale_color_identity()

# Save the plot
ggsave("figures/hspc_point_error_plot_gene.png", plot = hspc_point_error_plot_gene, width = 10, height = 6, dpi = 300)
```

```{r}
# Here i am doing the same thing but with the lthsc data set 
lthsc_summary_gene <- lthsc |>
  pivot_longer(cols = -ensembl_gene_id,
               names_to = "cell",
               values_to = "expr") |>
  group_by(ensembl_gene_id) |>
  summarise(min = min(expr),
            lowerq = quantile(expr, 0.25),
            sd = sd(expr),
            mean = mean(expr),
            median = median(expr),
            upperq = quantile(expr, 0.75),
            max = max(expr),
            total = sum(expr),
            n_zero = sum(expr == 0))


lthsc_point_error_plot_gene <- lthsc_summary_gene |> 
  ggplot(aes(x = reorder(ensembl_gene_id, mean), y = mean)) +
  geom_pointrange(aes(ymin = mean - sd, ymax = mean + sd, color = "darkgreen"),
                  size = 0.1) +
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd, color = "green"),
                width = 0.1) +
  theme_minimal() +
  theme(axis.line.x = element_line(color = "black", size = 1),  # Adjust x-axis line
        axis.line.y = element_line(color = "black", size = 1),
        axis.text = element_text(size = 30),  # Increase axis text size
        axis.title = element_text(size = 35),  # Increase axis title size
        axis.line = element_line(size = 2), 
        axis.text.x = element_blank(),
        plot.title = element_text(size = 40, hjust = 0.5,  colour = 'green3', face = "bold")) +
  labs(x = "genes", y = "Mean Expression", title = "LT.HSC") +
  scale_color_identity()

# Save the plot
ggsave("figures/lthsc_point_error_plot_gene.png", plot = lthsc_point_error_plot_gene, width = 10, height = 6, dpi = 300)
```

```{r}
#| label: fig-panel-point-error-plot-gene
#| fig.cap: "Distribution Of The Mean Expression Of Each Gene. Each figure above represents the distribution of gene expression across the 3 cell types derived from the single cell RNA sequencing data with genes ordered corresponding their mean expression along the X axis and mean expression along the Y axis. Each dot represents the mean expression level of each gene for all of the cells for that specific cell type, the error bars extending from each point show the range of expression values of that gene within one standard deviation. Data analysis was conducted in R (R Core Team 2023) with patchwork, tidyverse packages (Pedersen et al. 2023; Wickham et al. 2019)"
#| fig.align: "right"
#| fig.width: 25
#| fig.height: 7

# again we are utilising the patchwork package to combine the plots 
panel_point_error_plot_gene <- prog_point_error_plot_gene + lthsc_point_error_plot_gene + hspc_point_error_plot_gene + 
  plot_layout(guides = 'collect') 

# Again like with the histogram panel and cell mean expression plot we are specifying that the graphs be ordered next to each other and specificy the height of the panel 
panel_point_error_plot_gene <- panel_point_error_plot_gene + 
  plot_layout(ncol = 3, heights = c(40, 2, 2)) # Adjust 'ncol' and 'heights' as needed

panel_point_error_plot_gene
```

```{r}
# here i am just writing csv files of the data we processed and analysed.
write_csv(lthsc_summary_gene, "processed_data/lthsc_summary_gene.csv")
write_csv(hspc_summary_gene, "processed_data/hspc_summary_gene.csv")
write_csv(prog_summary_gene, "processed_data/prog_summary_gene.csv")
```

```{r}
# here we are writing the data as a html to be uploaded to github so a URL can be made so the reader of the output can see the file. 

# Create interactive DT tables for each dataset
dt_prog_gene <- datatable(prog_summary_gene, options = list(pageLength = 10, searchHighlight = TRUE))
dt_hspc_gene <- datatable(hspc_summary_gene, options = list(pageLength = 10, searchHighlight = TRUE))
dt_lthsc_gene <- datatable(lthsc_summary_gene, options = list(pageLength = 10, searchHighlight = TRUE))

# Save the DT tables as HTML files
saveWidget(dt_prog_gene, "processed_data/HTML/prog_summary_gene.html", selfcontained = TRUE)
saveWidget(dt_hspc_gene, "processed_data/HTML/hspc_summary_gene.html", selfcontained = TRUE)
saveWidget(dt_lthsc_gene, "processed_data/HTML/lthsc_summary_gene.html", selfcontained = TRUE)
```

now we have looked into the data sets and ensured that the there is sufficient gene expression across the cells and cell types we wanted to analyse the differences in gene expression across the cell types. We did this by perfroming a differential expression analysis, utilising the same techniques used by [@rand2023]. So we compared the HSPC to prog dataset, HSPC to LT.HSC dataset and Prog to LT.HSC dataset. to compare firstly the HSPC and Prog datasets we combined the two datasets of 701 and 798 cells into one dataset of 1499 cells, to create a new data set, [Prog_HSPC](https://joewomersley.github.io/report_quarto/prog_hspc.html), using the R studio ([R Core Team 2023](https://www.R-project.org/)) with tidyverse packages [@wickham2019]. We then repeated this to create two other data sets: [HSPC_LT.HSC](https://joewomersley.github.io/report_quarto/lthsc_hspc.html) and [Prog_LT.HSC](https://joewomersley.github.io/report_quarto/prog_hspc.html). We then conducted a differential expression analysis of these data sets to determine if specific genes are expressed higher in one cell type over the other. The differential expression analysis allows for the determination of the summary.logFC, whereby higher values indicate a greater level of differental gene expression in one cell type over the other. Again we conducted this analysis in R studio ([R Core Team 2023](https://www.R-project.org/)) with scran and tidyverse packages [@lun2016; @wickham2019]. For the [Prog vs HSPC](https://joewomersley.github.io/report_quarto/dt_prog_hspc_results_sig0.01.html) comparison, Positive fold change indicates a differential expression where expression is higher in the progenitors than the HSPCs. Similarly for the [HSPC VS LT.HSC](https://joewomersley.github.io/report_quarto/dt_lthsc_hspc_results_sig0.01.html) comparison, positive log fold change indicates a differential expression where expression is higher in LT.HSCs than the HSPCs. additionally, for the [Prog vs LT.HSC](https://joewomersley.github.io/report_quarto/dt_prog_lthsc_results_sig0.01.html) comparision, positive log fold change indicates a differential expression where expression is higher in progenitors than the HSPCs.

```{r}
#| include: false
#firstly to perfrom the differential analysis we must ensure that for the gene ids are in the same order in both dataframes:
identical(prog$ensembl_gene_id, hspc$ensembl_gene_id)

# we then combined the two dataframes (minus the gene ids) into one dataframe:
prog_hspc <- bind_cols(prog[-1], hspc[-1])

# next we add back the ensembl_gene_ids as row names, we remvoe and then add them so that there is not two rows of ensembl_gene_ids: 
row.names(prog_hspc) <- prog$ensembl_gene_id

# here we are just creating a vector that indicates which column belongs to which cell type.
cell_type <- rep(c("prog","hspc"), 
                 times = c(length(prog) - 1,
                           length(hspc) - 1))

#then we use this vector and the combined data set to run a differnetial expression analysis:
res_prog_hspc <- findMarkers(prog_hspc, 
                               cell_type)

# findMarkers() is the function that runs the differential expression analysis. 
# The first argument is the dataframe containing the data. The second argument 
# is the vector indicating which columns are in which cell type. 

# The dataframe res_prog_hspc$prog is log prog - log hspc (i.e.,Prog/HSPC). 
# This means - Positive fold change: prog is higher than hspc - 
# Negative fold change: hspc is higher than prog

prog_hspc_results <- data.frame(res_prog_hspc$prog, 
           ensembl_gene_id = row.names(res_prog_hspc$prog))

# Here we are filtering the results to only show comparisons that are significant:
prog_hspc_results_sig0.01 <- prog_hspc_results |> 
  filter(FDR <= 0.01)
```

```{r}
#| include: false
# here i am just writing csv files of the data we processed and analysed.
write_csv(prog_hspc, "comparisons/prog_hspc.csv")
write_csv(prog_hspc_results_sig0.01, "results/prog_hspc_results_sig0.01.csv")

```

```{r}
#| include: false
#writing as a html to be uploaded to github so a URL can be made so reader can be shown the data in our render

# Create interactive DT tables for each dataset
dt_prog_hspc <- datatable(prog_hspc, options = list(pageLength = 10, searchHighlight = TRUE))
dt_prog_hspc_results_sig0.01 <- datatable(prog_hspc_results_sig0.01, options = list(pageLength = 10, searchHighlight = TRUE))


# Save the DT tables as HTML files
saveWidget(dt_prog_hspc, "comparisons/HTML/prog_hspc.html", selfcontained = TRUE)
saveWidget(dt_prog_hspc_results_sig0.01, "results/HTML/dt_prog_hspc_results_sig0.01.html", selfcontained = TRUE)

```

```{r}
#| include: false
# now we can perfrom the differential analysis on a different comparison; lthsc vs hspc data sets: 
identical(lthsc$ensembl_gene_id, hspc$ensembl_gene_id)

# we then combined the two dataframes (minus the gene ids) into one dataframe:
lthsc_hspc <- bind_cols(lthsc[-1], hspc[-1])

# adding back the ensembl_gene_ids as row names: 
row.names(lthsc_hspc) <- lthsc$ensembl_gene_id

# here we are just creating a vector that indicates which column belongs to which cell type.
cell_type <- rep(c("lthsc","hspc"), 
                 times = c(length(lthsc) - 1,
                           length(hspc) - 1))

#then we use this vector and the combined data set to run a differnetial expression analysis:
res_lthsc_hspc <- findMarkers(lthsc_hspc, 
                             cell_type)


lthsc_hspc_results <- data.frame(res_lthsc_hspc$lthsc, 
           ensembl_gene_id = row.names(res_lthsc_hspc$lthsc))

lthsc_hspc_results_sig0.01 <- lthsc_hspc_results |> 
  filter(FDR <= 0.01)
```

```{r}
# again here i am just writing csv files of the data we processed and analysed.
write_csv(lthsc_hspc, "comparisons/lthsc_hspc.csv")
write_csv(lthsc_hspc_results_sig0.01, "results/lthsc_hspc_results_sig0.01.csv")
```

```{r}
#again we are writing as a html to be uploaded to github so a URL can be made so the reader can be shown the data in the render

# Create interactive DT tables for each dataset
dt_lthsc_hspc <- datatable(lthsc_hspc, options = list(pageLength = 10, searchHighlight = TRUE))
dt_lthsc_hspc_results_sig0.01 <- datatable(lthsc_hspc_results_sig0.01, options = list(pageLength = 10, searchHighlight = TRUE))


# Save the DT tables as HTML files
saveWidget(dt_lthsc_hspc, "comparisons/HTML/lthsc_hspc.html", selfcontained = TRUE)
saveWidget(dt_lthsc_hspc_results_sig0.01, "results/HTML/dt_lthsc_hspc_results_sig0.01.html", selfcontained = TRUE)
```

```{r}
#| include: false
# now we can perfrom the differential analysis on a different comparison; lthsc vs hspc data sets: 
identical(prog$ensembl_gene_id, lthsc$ensembl_gene_id)

# we then combined the two dataframes (minus the gene ids) into one dataframe:
prog_lthsc<- bind_cols(prog[-1], lthsc[-1])

# adding back the ensembl_gene_ids as row names: 
row.names(prog_lthsc) <- prog$ensembl_gene_id

# here we are just creating a vector that indicates which column belongs to which cell type.
cell_type <- rep(c("prog","lthsc"), 
                 times = c(length(prog) - 1,
                           length(lthsc) - 1))

#then we use this vector and the combined data set to run a differnetial expression analysis:
res_prog_lthsc <- findMarkers(prog_lthsc, 
                             cell_type)


prog_lthsc_results <- data.frame(res_prog_lthsc$prog, 
           ensembl_gene_id = row.names(res_prog_lthsc$prog))

prog_lthsc_results_sig0.01 <- prog_lthsc_results |> 
  filter(FDR <= 0.01)
```

```{r}
# here again i am just writing csv files of the data we processed and analysed.
write_csv(prog_lthsc, "comparisons/prog_lthsc.csv")
write_csv(prog_lthsc_results_sig0.01, "results/prog_lthsc_results_sig0.01.csv")
```

```{r}
#writing as a html to be uploaded to github so a URL can be made so the reader can be shown the data in the render. 

# Create interactive DT tables for each dataset
dt_prog_lthsc <- datatable(prog_lthsc, options = list(pageLength = 10, searchHighlight = TRUE))
dt_prog_lthsc_results_sig0.01 <- datatable(prog_lthsc_results_sig0.01, options = list(pageLength = 10, searchHighlight = TRUE))


# Save the DT tables as HTML files
saveWidget(dt_prog_lthsc, "comparisons/HTML/prog_lthsc.html", selfcontained = TRUE)
saveWidget(dt_prog_lthsc_results_sig0.01, "results/HTML/dt_prog_lthsc_results_sig0.01.html", selfcontained = TRUE)
```

we next wanted to be able to visualise the data set and differential expression analysis through a Table. Firstly we merged the combined data sets and differential expression analysis results and used biomart data base to add gene infromation from ensembl [@Martin2023; @Birney2004; @Durinck2009]. This allowed for genes names to replace the ensembl gene ids. additionally, to be able to understand further the differential gene analysis, we added columns that showed the average gene expression for each gene across the three different cell types, along with the FDR and p.value to show that the comparisons are significant. Finally we added a column that represented the comparison. We filtered the data however to only show comparision that were signifcant (P \<0.05) and comparisons that showed differential gene expression (summary.logFC \> 1). Again utilising the same techniques used by [@rand2023]. This however brought forward an issue; the same genes were differentially expressed in more than one comparison so we created interactive tables with and without the duplicate genes. We thought it important to include the data set with duplicates removed as one could determine the top 20 deferentially expressed genes for further visualisation through a heatmap (Table 1 and 2).

```{r}
#| include: false
# so we are connecting to the ensembl mouse database using biomart so we can add in gene information including gene names. 

ensembl <- useMart(biomart = "ensembl", 
                   dataset = "mmusculus_gene_ensembl")

# See what information we can retrieve
listAttributes(mart = ensembl) |> head(20)

```

```{r}
#| include: false
# We use the getBM() function to retrieve information from the database. The filters argument is used to specified what kind of identifier we are supplying to retrieve information. The attributes argument is used to select the information we want to retrieve, which in this case is the external gene names for the ensembl_gene_ids that are in our data set. 

gene_info <- getBM(filters = "ensembl_gene_id",
                   attributes = c("ensembl_gene_id",
                                  "external_gene_name",
                                  "description"),
                   values = prog_hspc_results$ensembl_gene_id,
                   mart = ensembl)

# Notice the dataframe, gene_info, returned only has 279 rows 
# indicating one of the ids does not have information.
# We can find which is missing with:
  
prog_hspc_results |> dplyr::select(ensembl_gene_id) |> 
    filter(!ensembl_gene_id %in% gene_info$ensembl_gene_id)

# next we can Merge the gene information with the results:

prog_hspc_results <- prog_hspc_results |> 
  left_join(gene_info, by = "ensembl_gene_id")

# Create a dataframe of the genes significant at the 0.01 level:

prog_hspc_results_with_geneinfo_sig0.01 <- prog_hspc_results |> 
  filter(FDR <= 0.01)
```

```{r}
# we are wrting the data frames as csv files here: 
write_csv(prog_hspc_results_with_geneinfo_sig0.01, "results/prog_hspc_results_with_geneinfo_sig0.01.csv")
```

```{r}
#writing as a html to be uploaded to github so a URL can be made so the reader can be shown the data in our render. 

# Create interactive DT tables for each dataset
dt_prog_hspc_results_with_geneinfo_sig0.01 <- datatable(prog_hspc_results_with_geneinfo_sig0.01, options = list(pageLength = 10, searchHighlight = TRUE))


# Save the DT tables as HTML files
saveWidget(dt_prog_hspc_results_with_geneinfo_sig0.01, "results/HTML/dt_prog_hspc_results_with_geneinfo_sig0.01.html", selfcontained = TRUE)
```

```{r}
#| include: false
# we do the same again for the other comparisions: 

gene_info <- getBM(filters = "ensembl_gene_id",
                   attributes = c("ensembl_gene_id",
                                  "external_gene_name",
                                  "description"),
                   values = lthsc_hspc_results$ensembl_gene_id,
                   mart = ensembl)

# Notice the dataframe, gene_info, returned only has 279 rows 
# indicating one of the ids does not have information.
# We can find which is missing with:
  
lthsc_hspc_results |> select(ensembl_gene_id) |> 
  filter(!ensembl_gene_id %in% gene_info$ensembl_gene_id)

# next we can Merge the gene information with the results:

lthsc_hspc_results <- lthsc_hspc_results |> left_join(gene_info, by = "ensembl_gene_id")    

# Create a dataframe of the genes significant at the 0.01 level:

lthsc_hspc_results_with_geneinfo_sig0.01 <- lthsc_hspc_results |> 
  filter(FDR <= 0.01)
```

```{r}
# again writing the a csv file of our results: 
write_csv(lthsc_hspc_results_with_geneinfo_sig0.01, "results/lthsc_hspc_results_with_geneinfo_sig0.01.csv")
```

```{r}
#writing as a html to be uploaded to github so a URL can be made so the reader can be shown the data in our render:

# Create interactive DT tables for each dataset
dt_lthsc_hspc_results_with_geneinfo_sig0.01 <- datatable(lthsc_hspc_results_with_geneinfo_sig0.01, options = list(pageLength = 10, searchHighlight = TRUE))


# Save the DT tables as HTML files
saveWidget(dt_lthsc_hspc_results_with_geneinfo_sig0.01, "results/HTML/dt_lthsc_hspc_results_with_geneinfo_sig0.01.html", selfcontained = TRUE)
```

```{r}
#| include: false
# we do the same again for the other comparisions: 

gene_info <- getBM(filters = "ensembl_gene_id",
                   attributes = c("ensembl_gene_id",
                                  "external_gene_name",
                                  "description"),
                   values = prog_lthsc_results$ensembl_gene_id,
                   mart = ensembl)

# Notice the dataframe, gene_info, returned only has 279 rows 
# indicating one of the ids does not have information.
# We can find which is missing with:
  
prog_lthsc_results |> select(ensembl_gene_id) |> 
  filter(!ensembl_gene_id %in% gene_info$ensembl_gene_id)

# next we can Merge the gene information with the results:

prog_lthsc_results <- prog_lthsc_results |> left_join(gene_info, by = "ensembl_gene_id")   

# Create a dataframe of the genes significant at the 0.01 level:

prog_lthsc_results_with_geneinfo_sig0.01 <- prog_lthsc_results |> 
  filter(FDR <= 0.01)
```

```{r}
# again here i am just writing csv files of the data we processed and analysed.
write_csv(prog_lthsc_results_with_geneinfo_sig0.01, "results/prog_lthsc_results_with_geneinfo_sig0.01.csv")
```

```{r}
#writing as a html to be uploaded to github so a URL can be made so. reader can be shown the data in a web browser

# Create interactive DT tables for each dataset
dt_prog_lthsc_results_with_geneinfo_sig0.01 <- datatable(prog_lthsc_results_with_geneinfo_sig0.01, options = list(pageLength = 10, searchHighlight = TRUE))


# Save the DT tables as HTML files
saveWidget(dt_prog_lthsc_results_with_geneinfo_sig0.01, "results/HTML/dt_prog_lthsc_results_with_geneinfo_sig0.01.html", selfcontained = TRUE)
```

```{r}
# i have previosuly read in the raw data files but here i am reading them in with the row names being the ensembl_gene_ids. this could be acheived by directly manipulating each data set already read in but this is a very easy way to acheive the same output, but now not all the previous code using the raw data will run unless you read in the data once again where we dont specifcy the row names. 
hspc <- read.csv("data_raw/surfaceome_hspc.csv", row.names = 1)
prog <- read.csv("data_raw/surfaceome_prog.csv", row.names = 1)
lthsc <- read.csv("data_raw/surfaceome_lthsc.csv", row.names = 1)
```

```{r}
#| include: false
# Add a comparison column to each dataset
prog_lthsc_results_with_geneinfo_sig0.01$comparison <- 'prog_lthsc'
lthsc_hspc_results_with_geneinfo_sig0.01$comparison <- 'lthsc_hspc'
prog_hspc_results_with_geneinfo_sig0.01$comparison <- 'prog_hspc'

# Combine the datasets
combined_results <- bind_rows(prog_lthsc_results_with_geneinfo_sig0.01, lthsc_hspc_results_with_geneinfo_sig0.01, prog_hspc_results_with_geneinfo_sig0.01)

# Calculate the absolute value of summary.logFC for sorting and round to 3sf. This is basically the summary.LogFC but takes away the negative so -1 will turn to 1 so this allows us to rank based on this as high negative and high postive nubmber both correlate to high differential expression: 
combined_results <- combined_results %>%
  dplyr::mutate(abs_summary.logFC = signif(abs(summary.logFC), 4))

# Sort by absolute summary.logFC and FDR (rounded to 3sf), then remove duplicates based on ensembl_gene_id

sorted_combined_results <- combined_results %>%
  dplyr::mutate(FDR_formatted = format(FDR, scientific = TRUE, digits = 4)) %>%
  dplyr::arrange(desc(abs_summary.logFC), FDR) %>%
  dplyr::distinct(ensembl_gene_id, .keep_all = TRUE)


# Calculate the number of genes meeting the specified criteria
significant_genes <- sorted_combined_results %>%
  filter(p.value < 0.05, abs(summary.logFC) > 1)

# Get the count of significant genes
num_significant_genes_no_duplicates <- nrow(significant_genes)

# Get the top 101 unique differentially expressed genes whih are classed as significant and differentially expressed above: 
top_differentially_expressed_genes <- head(sorted_combined_results, 101)

# Select relevant columns and round numerical columns to 3sf
top_differentially_expressed_genes <- top_differentially_expressed_genes %>%
  dplyr::select(p.value, FDR, summary.logFC, external_gene_name, comparison, ensembl_gene_id) %>%
  dplyr::mutate(
    p.value = signif(p.value, 4),
    FDR = signif(FDR, 4),
    summary.logFC = signif(summary.logFC, 4)
  )

# Here i am selecting those 101 genes manually i could have in coded this from our vector, but i encountered many error s when trying to do so, hence this is a work round, but is not very reproducable: 
gene_ids <- c(
"ENSMUSG00000027611",
"ENSMUSG00000054641",
"ENSMUSG00000001946",
"ENSMUSG00000015355",
"ENSMUSG00000016494",
"ENSMUSG00000038235",
"ENSMUSG00000041329",
"ENSMUSG00000024053",
"ENSMUSG00000002808",
"ENSMUSG00000026748",
"ENSMUSG00000030745",
"ENSMUSG00000003420",
"ENSMUSG00000035206",
"ENSMUSG00000036594",
"ENSMUSG00000022816",
"ENSMUSG00000021728",
"ENSMUSG00000025780",
"ENSMUSG00000059588",
"ENSMUSG00000031170",
"ENSMUSG00000028639",
"ENSMUSG00000030117",
"ENSMUSG00000022797",
"ENSMUSG00000053063",
"ENSMUSG00000037405",
"ENSMUSG00000020238",
"ENSMUSG00000025351",
"ENSMUSG00000030336",
"ENSMUSG00000022309",
"ENSMUSG00000030062",
"ENSMUSG00000026581",
"ENSMUSG00000034881",
"ENSMUSG00000005087",
"ENSMUSG00000037649",
"ENSMUSG00000052593",
"ENSMUSG00000026837",
"ENSMUSG00000030830",
"ENSMUSG00000025790",
"ENSMUSG00000026566",
"ENSMUSG00000026072",
"ENSMUSG00000004631",
"ENSMUSG00000028645",
"ENSMUSG00000021427",
"ENSMUSG00000031990",
"ENSMUSG00000079037",
"ENSMUSG00000026395",
"ENSMUSG00000047953",
"ENSMUSG00000027642",
"ENSMUSG00000023942",
"ENSMUSG00000036503",
"ENSMUSG00000027435",
"ENSMUSG00000024462",
"ENSMUSG00000032412",
"ENSMUSG00000002897",
"ENSMUSG00000032336",
"ENSMUSG00000030605",
"ENSMUSG00000026923",
"ENSMUSG00000031934",
"ENSMUSG00000062585",
"ENSMUSG00000028469",
"ENSMUSG00000027408",
"ENSMUSG00000022636",
"ENSMUSG00000026656",
"ENSMUSG00000038280",
"ENSMUSG00000031785",
"ENSMUSG00000027312",
"ENSMUSG00000013236",
"ENSMUSG00000000555",
"ENSMUSG00000004709",
"ENSMUSG00000030748",
"ENSMUSG00000034164",
"ENSMUSG00000028184",
"ENSMUSG00000003379",
"ENSMUSG00000026814",
"ENSMUSG00000004207",
"ENSMUSG00000027366",
"ENSMUSG00000024109",
"ENSMUSG00000068747",
"ENSMUSG00000053062",
"ENSMUSG00000045362",
"ENSMUSG00000024614",
"ENSMUSG00000016496",
"ENSMUSG00000024620",
"ENSMUSG00000023175",
"ENSMUSG00000030124",
"ENSMUSG00000005465",
"ENSMUSG00000074785",
"ENSMUSG00000030754",
"ENSMUSG00000020402",
"ENSMUSG00000032231",
"ENSMUSG00000040528",
"ENSMUSG00000020717",
"ENSMUSG00000022667",
"ENSMUSG00000004609",
"ENSMUSG00000032193",
"ENSMUSG00000037206",
"ENSMUSG00000035498",
"ENSMUSG00000057530",
"ENSMUSG00000021759",
"ENSMUSG00000015316",
"ENSMUSG00000024621",
"ENSMUSG00000040592")




# Create a vector to store the average expression of each gene
average_expression <- numeric(length(gene_ids))

# below i am calculating the average gene expression for each of the cell types and filtering for just those 101 genes. 

# prog --------------------------------------------------------------------

# Calculate the average expression for each gene
for (i in seq_along(gene_ids)) {
  gene_expression <- prog[gene_ids[i], ]
  gene_expression <- gene_expression[complete.cases(gene_expression), ]  # Remove rows with missing values
  average_expression[i] <- sum(gene_expression) / length(gene_expression)
}

# Create a dataframe with gene IDs and their average expression
prog_average_expression_df <- data.frame(
  Ensembl_gene_id = gene_ids,
  Prog = average_expression
)

# HSPC --------------------------------------------------------------------

# Calculate the average expression for each gene
for (i in seq_along(gene_ids)) {
  gene_expression <- hspc[gene_ids[i], ]
  gene_expression <- gene_expression[complete.cases(gene_expression), ]  # Remove rows with missing values
  average_expression[i] <- sum(gene_expression) / length(gene_expression)
}

# Create a dataframe with gene IDs and their average expression
HSPC_average_expression_df <- data.frame(
  Ensembl_gene_id = gene_ids,
  HSPC = average_expression
)

# LT.HSC ------------------------------------------------------------------

# Calculate the average expression for each gene
for (i in seq_along(gene_ids)) {
  gene_expression <- lthsc[gene_ids[i], ]
  gene_expression <- gene_expression[complete.cases(gene_expression), ]  # Remove rows with missing values
  average_expression[i] <- sum(gene_expression) / length(gene_expression)
}

# Create a dataframe with gene IDs and their average expression
lthsc_average_expression_df <- data.frame(
  Ensembl_gene_id = gene_ids,
  LT.HSC = average_expression
)

# adding to table ---------------------------------------------------------

# Merge with the average_expression_df for Prog
top_differentially_expressed_genes <- merge(top_differentially_expressed_genes, prog_average_expression_df, by.x = "ensembl_gene_id", by.y = "Ensembl_gene_id", all.x = TRUE)

# Merge with the average_expression_df for Prog
top_differentially_expressed_genes <- merge(top_differentially_expressed_genes, HSPC_average_expression_df, by.x = "ensembl_gene_id", by.y = "Ensembl_gene_id", all.x = TRUE)

# Merge with the average_expression_df for Prog
top_differentially_expressed_genes <- merge(top_differentially_expressed_genes, lthsc_average_expression_df, by.x = "ensembl_gene_id", by.y = "Ensembl_gene_id", all.x = TRUE)

# Order the dataframe based on the absolute values of summary.logFC column
top_differentially_expressed_genes <- top_differentially_expressed_genes[order(abs(top_differentially_expressed_genes$summary.logFC), decreasing = TRUE), ]

#we can now remove the ensembl_gene_id column
top_differentially_expressed_genes <- top_differentially_expressed_genes %>%
  select(-ensembl_gene_id)

# round the summary.logFC to 3sf
top_differentially_expressed_genes <- top_differentially_expressed_genes %>%
  dplyr::mutate(Prog = signif(abs(Prog), 4))

top_differentially_expressed_genes <- top_differentially_expressed_genes %>%
  dplyr::mutate(HSPC = signif(abs(HSPC), 4))

top_differentially_expressed_genes <- top_differentially_expressed_genes %>%
  dplyr::mutate(LT.HSC = signif(abs(LT.HSC), 4))

# rename to ensure is dustingushed from data set wuth duplicates 

top_differentially_expressed_genes_no_duplicates <- top_differentially_expressed_genes

```

```{r}
#| include: false
# now before we calculated the top 101 differentially expressed genes we had filtered out duplicates but it would be an interesting analysis to determine if genes are differentially expressed in more than one comparison. 

# Add a comparison column to each dataset
prog_lthsc_results_with_geneinfo_sig0.01$comparison <- 'prog_lthsc'
lthsc_hspc_results_with_geneinfo_sig0.01$comparison <- 'lthsc_hspc'
prog_hspc_results_with_geneinfo_sig0.01$comparison <- 'prog_hspc'

# Combine the datasets
combined_results <- bind_rows(prog_lthsc_results_with_geneinfo_sig0.01, lthsc_hspc_results_with_geneinfo_sig0.01, prog_hspc_results_with_geneinfo_sig0.01)

# Calculate the absolute value of summary.logFC for sorting and round to 3sf
combined_results <- combined_results %>%
  dplyr::mutate(abs_summary.logFC = signif(abs(summary.logFC), 4))

# Sort by absolute summary.logFC and FDR (rounded to 3sf), then remove duplicates based on ensembl_gene_id
sorted_combined_results <- combined_results %>%
  dplyr::mutate(FDR = signif(FDR, 4)) %>%
  dplyr::arrange(desc(abs_summary.logFC), FDR) 

# Calculate the number of genes meeting the specified criteria
significant_genes <- sorted_combined_results %>%
  filter(p.value < 0.05, abs(summary.logFC) > 1)

# Get the count of significant genes
num_significant_genes_with_duplicates <- nrow(significant_genes)

# Get the top 20 unique differentially expressed genes
top_differentially_expressed_genes <- head(sorted_combined_results, 182)

# Select relevant columns and round numerical columns to 3sf
top_differentially_expressed_genes <- top_differentially_expressed_genes %>%
  dplyr::select(p.value, FDR, summary.logFC, external_gene_name, comparison, ensembl_gene_id) %>%
  dplyr::mutate(
   p.value = sprintf("%.4g", p.value),
    FDR = sprintf("%.4g", FDR),
    summary.logFC = signif(summary.logFC, 4)
  )

# this is the 182 differentilly and significantly expressed genes, again this isnt very reproducable and could have been extracted from the code above isntead of manually creating the vector: 
gene_ids <- c(
"ENSMUSG00000027611",
"ENSMUSG00000054641",
"ENSMUSG00000001946",
"ENSMUSG00000015355",
"ENSMUSG00000016494",
"ENSMUSG00000038235",
"ENSMUSG00000041329",
"ENSMUSG00000041329",
"ENSMUSG00000016494",
"ENSMUSG00000024053",
"ENSMUSG00000024053",
"ENSMUSG00000002808",
"ENSMUSG00000026748",
"ENSMUSG00000030745",
"ENSMUSG00000030745",
"ENSMUSG00000003420",
"ENSMUSG00000002808",
"ENSMUSG00000035206",
"ENSMUSG00000027611",
"ENSMUSG00000036594",
"ENSMUSG00000022816",
"ENSMUSG00000027611",
"ENSMUSG00000021728",
"ENSMUSG00000035206",
"ENSMUSG00000025780",
"ENSMUSG00000059588",
"ENSMUSG00000031170",
"ENSMUSG00000028639",
"ENSMUSG00000030117",
"ENSMUSG00000025780",
"ENSMUSG00000022797",
"ENSMUSG00000053063",
"ENSMUSG00000031170",
"ENSMUSG00000037405",
"ENSMUSG00000020238",
"ENSMUSG00000054641",
"ENSMUSG00000022797",
"ENSMUSG00000025351",
"ENSMUSG00000030336",
"ENSMUSG00000022309",
"ENSMUSG00000022309",
"ENSMUSG00000021728",
"ENSMUSG00000030062",
"ENSMUSG00000026581",
"ENSMUSG00000034881",
"ENSMUSG00000038235",
"ENSMUSG00000015355",
"ENSMUSG00000005087",
"ENSMUSG00000020238",
"ENSMUSG00000037649",
"ENSMUSG00000052593",
"ENSMUSG00000026837",
"ENSMUSG00000030830",
"ENSMUSG00000025790",
"ENSMUSG00000001946",
"ENSMUSG00000054641",
"ENSMUSG00000026566",
"ENSMUSG00000026748",
"ENSMUSG00000001946",
"ENSMUSG00000026072",
"ENSMUSG00000004631",
"ENSMUSG00000028645",
"ENSMUSG00000021427",
"ENSMUSG00000030117",
"ENSMUSG00000030062",
"ENSMUSG00000031990",
"ENSMUSG00000079037",
"ENSMUSG00000026581",
"ENSMUSG00000015355",
"ENSMUSG00000026395",
"ENSMUSG00000047953",
"ENSMUSG00000027642",
"ENSMUSG00000023942",
"ENSMUSG00000030336",
"ENSMUSG00000036503",
"ENSMUSG00000027435",
"ENSMUSG00000024462",
"ENSMUSG00000032412",
"ENSMUSG00000002897",
"ENSMUSG00000032336",
"ENSMUSG00000030605",
"ENSMUSG00000036594",
"ENSMUSG00000026072",
"ENSMUSG00000026923",
"ENSMUSG00000031934",
"ENSMUSG00000062585",
"ENSMUSG00000027435",
"ENSMUSG00000030605",
"ENSMUSG00000028469",
"ENSMUSG00000025790",
"ENSMUSG00000025351",
"ENSMUSG00000027408",
"ENSMUSG00000003420",
"ENSMUSG00000022636",
"ENSMUSG00000028639",
"ENSMUSG00000026656",
"ENSMUSG00000038235",
"ENSMUSG00000062585",
"ENSMUSG00000038280",
"ENSMUSG00000031785",
"ENSMUSG00000027312",
"ENSMUSG00000005087",
"ENSMUSG00000013236",
"ENSMUSG00000047953",
"ENSMUSG00000000555",
"ENSMUSG00000004709",
"ENSMUSG00000026837",
"ENSMUSG00000024462",
"ENSMUSG00000030748",
"ENSMUSG00000053063",
"ENSMUSG00000002897",
"ENSMUSG00000030830",
"ENSMUSG00000034164",
"ENSMUSG00000034164",
"ENSMUSG00000028184",
"ENSMUSG00000003379",
"ENSMUSG00000022816",
"ENSMUSG00000036503",
"ENSMUSG00000032336",
"ENSMUSG00000031785",
"ENSMUSG00000026814",
"ENSMUSG00000004207",
"ENSMUSG00000027366",
"ENSMUSG00000031934",
"ENSMUSG00000021427",
"ENSMUSG00000059588",
"ENSMUSG00000079037",
"ENSMUSG00000024109",
"ENSMUSG00000022636",
"ENSMUSG00000022816",
"ENSMUSG00000037405",
"ENSMUSG00000028184",
"ENSMUSG00000068747",
"ENSMUSG00000034881",
"ENSMUSG00000053062",
"ENSMUSG00000045362",
"ENSMUSG00000024614",
"ENSMUSG00000016496",
"ENSMUSG00000032412",
"ENSMUSG00000004207",
"ENSMUSG00000004631",
"ENSMUSG00000059588",
"ENSMUSG00000003420",
"ENSMUSG00000003379",
"ENSMUSG00000024620",
"ENSMUSG00000023175",
"ENSMUSG00000030124",
"ENSMUSG00000005465",
"ENSMUSG00000074785",
"ENSMUSG00000030754",
"ENSMUSG00000020402",
"ENSMUSG00000027642",
"ENSMUSG00000032231",
"ENSMUSG00000040528",
"ENSMUSG00000020717",
"ENSMUSG00000026566",
"ENSMUSG00000020402",
"ENSMUSG00000022667",
"ENSMUSG00000052593",
"ENSMUSG00000068747",
"ENSMUSG00000024109",
"ENSMUSG00000004609",
"ENSMUSG00000032193",
"ENSMUSG00000037206",
"ENSMUSG00000035498",
"ENSMUSG00000057530",
"ENSMUSG00000027366",
"ENSMUSG00000021759",
"ENSMUSG00000028645",
"ENSMUSG00000037649",
"ENSMUSG00000020717",
"ENSMUSG00000053062",
"ENSMUSG00000026395",
"ENSMUSG00000037405",
"ENSMUSG00000027312",
"ENSMUSG00000026814",
"ENSMUSG00000023175",
"ENSMUSG00000015316",
"ENSMUSG00000024621",
"ENSMUSG00000023942",
"ENSMUSG00000038280",
"ENSMUSG00000040592")


# Create a vector to store the average expression of each gene
average_expression <- numeric(length(gene_ids))

# again we are calculating the average expression and filtering for those 182 genes: 

# prog --------------------------------------------------------------------

# Calculate the average expression for each gene
for (i in seq_along(gene_ids)) {
  gene_expression <- prog[gene_ids[i], ]
  gene_expression <- gene_expression[complete.cases(gene_expression), ]  # Remove rows with missing values
  average_expression[i] <- sum(gene_expression) / length(gene_expression)
}

# Create a dataframe with gene IDs and their average expression
prog_average_expression_df <- data.frame(
  Ensembl_gene_id = gene_ids,
  Prog = average_expression
)

# HSPC --------------------------------------------------------------------

# Calculate the average expression for each gene
for (i in seq_along(gene_ids)) {
  gene_expression <- hspc[gene_ids[i], ]
  gene_expression <- gene_expression[complete.cases(gene_expression), ]  # Remove rows with missing values
  average_expression[i] <- sum(gene_expression) / length(gene_expression)
}

# Create a dataframe with gene IDs and their average expression
HSPC_average_expression_df <- data.frame(
  Ensembl_gene_id = gene_ids,
  HSPC = average_expression
)

# LT.HSC ------------------------------------------------------------------

# Calculate the average expression for each gene
for (i in seq_along(gene_ids)) {
  gene_expression <- lthsc[gene_ids[i], ]
  gene_expression <- gene_expression[complete.cases(gene_expression), ]  # Remove rows with missing values
  average_expression[i] <- sum(gene_expression) / length(gene_expression)
}

# Create a dataframe with gene IDs and their average expression
lthsc_average_expression_df <- data.frame(
  Ensembl_gene_id = gene_ids,
  LT.HSC = average_expression
)

# adding to table ---------------------------------------------------------

# Merge with the average_expression_df for Prog
# Add the Prog average expression column
top_differentially_expressed_genes$Prog <- prog_average_expression_df$Prog

# Merge with the average_expression_df for HSPC
top_differentially_expressed_genes$HSPC <- HSPC_average_expression_df$HSPC

# Merge with the average_expression_df for LT.HSC
top_differentially_expressed_genes$LT_HSC <- lthsc_average_expression_df$LT.HSC

# Order the dataframe based on the absolute values of summary.logFC column
top_differentially_expressed_genes <- top_differentially_expressed_genes[order(abs(top_differentially_expressed_genes$summary.logFC), decreasing = TRUE), ]

#we can now remove the ensembl_gene_id column
top_differentially_expressed_genes <- top_differentially_expressed_genes %>%
  select(-ensembl_gene_id)

# round the summary.logFC to 3sf
top_differentially_expressed_genes <- top_differentially_expressed_genes %>%
  dplyr::mutate(Prog = signif(abs(Prog), 4))

top_differentially_expressed_genes <- top_differentially_expressed_genes %>%
  dplyr::mutate(HSPC = signif(abs(HSPC), 4))

top_differentially_expressed_genes <- top_differentially_expressed_genes %>%
  dplyr::mutate(LT_HSC = signif(abs(LT_HSC), 4))

#rename to distingush that there are duplicates

top_differentially_expressed_genes_duplicates <- top_differentially_expressed_genes

```

::: {#fig-top-differentially-expressed-genes layout-ncol="1" style="display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap;"}
```{r label-of-your-choice-a, echo=FALSE, results='asis'}
#| label: fig-top-differentially-expressed-genes-no-duplicates
#| fig.cap: "Top differentially expressed genes with no duplicates."
#| fig.align: "right"
#| fig.width: 25
#| fig.height: 7

# I am now visualising the table for our render 

# Convert FDR and other numeric columns to strings with desired formatting. So this is making use that the really small numbers that are in the p.value and FDR columns we only show 3 decimial points in the e^. 
top_differentially_expressed_genes_no_duplicates <- top_differentially_expressed_genes_no_duplicates %>%
  mutate(FDR = sprintf("%.3e", FDR),
         p.value = sprintf("%.3e", p.value))

# Now create the datatable which is a more interactive version: 
datatable(top_differentially_expressed_genes_no_duplicates, rownames = FALSE,
          options = list(
            pageLength = 10,
            searchHighlight = TRUE,
            scrollY = "300px",
            scrollCollapse = TRUE
          ),
          width = "100%", escape = FALSE)

```

```{r label-of-your-choice, echo=FALSE, results='asis'}
#| label: fig-top-differentially-expressed-genes-duplicates
#| fig.cap: "Top differentially expressed genes with duplicates"
#| fig.align: "right"
#| fig.width: 25
#| fig.height: 7

# creating an interactive version of the table to be rendered in the html 
datatable(top_differentially_expressed_genes_duplicates, rownames = FALSE,
          options = list(
            pageLength = 10,
            searchHighlight = TRUE,
            scrollY = "300px",
            scrollCollapse = TRUE
          ),
          width = "100%", escape = FALSE)

```

The differentially expressed genes are defined by a differential gene analysis. FDR corresponds to false discovery rate using the Benjamini-Hochberg procedure. Due to the multiple comparisons problem in gene expression analysis (testing many genes), the p-value is adjusted to control the false discovery rate, which is the expected proportion of false positives. Summary.logFC corresponds to the log fold change which is the measure of the difference in expression levels of a gene between two of the three cell-types. Higher Summary.logFC values indicate a higher level of differential expression. note negative and positive high numbers both correspond with a high level of differential expression this just corresponds to the swing in expression whereby negative numbers correspond to higher expression in the second cell type in the comparison. The data was also filtered to only show comparisons with a P.value less than 0.05. Data analysis as conducted in R (R Core Team 2023) with biomart, DT, Scran, htmlTable, Conflicted and tidyverse packages (Durinck et al. 2009; Xie et al. 2023; lun et al. 2016; gordon et al. 2023; Wickham et al. 2023; Wickham et al. 2019). Top 20 Differentially expressed genes with duplicates. The differentially expressed genes are defined by a differential gene analysis. FDR corresponds to false discovery rate using the Benjamini-Hochberg procedure. Due to the multiple comparisons problem in gene expression analysis (testing many genes), the p-value is adjusted to control the false discovery rate, which is the expected proportion of false positives. Summary.logFC corresponds to the log fold change which is the measure of the difference in expression levels of a gene between two of the three cell-types. Higher Summary.logFC values indicate a higher level of differential expression. note negative and positive high numbers both correspond with a high level of differential expression this just corresponds to the swing in expression whereby negative numbers correspond to higher expression in the second cell type in the comparison. The data was also filtered to only show comparisons with a P.value less than 0.05. Data analysis as conducted in R (R Core Team 2023) with biomart, DT, Scran, htmlTable, Conflicted and tidyverse packages (Durinck et al. 2009; Xie et al. 2023; lun et al. 2016; gordon et al. 2023; Wickham et al. 2023; Wickham et al. 2019)
:::

Next we wanted to view the differential gene analysis, the best way to do this is through a volcano plot. We did this by first taking our results data sets and plotting the summary.LogFC which represented the differental expression of specific genes against FDR. this allowed for the determination of genes that are differentailly expressed, significantly. To be able to match what genes is each point in the volcano plot we again connected with the Ensembl database [@Martin2023; @Birney2004; @Durinck2009] using biomaRt [@Durinck2009]. This allowed the addition of gene names to label points with high summary.LogFC, additionally we coloured points pink to show significantly differentially expressed genes.

```{r}
# we need to read in the raw data again with the row names not the ensembl_gene_id as we are using that column to bind the prog_hspc to the results. This could have been done better in hindsight using a different name for the data when the ensembl_gene_id is the row name. 
hspc <- read.csv("data_raw/surfaceome_hspc.csv")
prog <- read.csv("data_raw/surfaceome_prog.csv")
lthsc <- read.csv("data_raw/surfaceome_lthsc.csv")
```

```{r}
#creating the combined data set with the ensembl_gene_id as the first column and not the column name: 
prog_hspc <- bind_cols(prog, hspc[-1])

#adding the combined data to the results 
prog_hspc_results <- prog_hspc_results |> 
  left_join(prog_hspc, by = "ensembl_gene_id")

# this is ensuring points are coloured if FDR < 0.05 and label points with the external gene name if there summary.LogFC is greater than 2.5. 
prog_hspc_results <- prog_hspc_results |> 
  mutate(log10_FDR = -log10(FDR),
         sig = FDR < 0.05,
         bigfc = abs(summary.logFC) >= 2.5)   

# Create a data frame for the highlight region
highlight_region <- data.frame(
  xmin = -1.5,
  xmax = 1.5,
  ymin = -Inf,
  ymax = -log10(0.05)
)

# here we are generating a a volcano plot shoing the comparison between progs and hspcs: 

vol_prog_hspc <- ggplot() +
  geom_point(data = prog_hspc_results, aes(x = summary.logFC, y = log10_FDR, colour = interaction(sig, bigfc)), size = 4, alpha = 1) +
  geom_hline(data = prog_hspc_results, aes(yintercept = -log10(0.05)), linetype = "dashed") +
  geom_vline(data = prog_hspc_results, aes(xintercept = 1), linetype = "dashed") +
  geom_vline(data = prog_hspc_results, aes(xintercept = -1), linetype = "dashed") +
  geom_rect(data = highlight_region, aes(xmin = 1, xmax = 3.5, ymin = 0, ymax = 150), fill = "darkblue", alpha = 0.15) +
  geom_rect(data = highlight_region, aes(xmin = -3.2, xmax = -1, ymin = 0, ymax = 150), fill = "red", alpha = 0.15) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_colour_manual(values = c("gray", "pink", "deeppink")) +
  geom_text_repel(data = subset(prog_hspc_results, bigfc & sig), aes(x = summary.logFC, y = log10_FDR, label = external_gene_name), size = 7, max.overlaps = 50, vjust = 1.9) +
  theme_classic() +
  theme(legend.position = "none", 
        axis.title = element_text(size = 30), axis.text = element_text(size = 30),
        plot.title = element_text(size = 40, hjust = 0.5),
        plot.margin = margin(t = 30)) +
  ggtitle("Progs vs HSPC")

# Save the plot
ggsave("figures/vol_prog_hspc.png", plot = vol_prog_hspc, width = 10, height = 6, dpi = 300)
```

```{r}

# here we are doing the same for a different comparison.
#creating the combined data set with the ensembl_gene_id as the first column and not the column name: 
prog_lthsc <- bind_cols(prog, lthsc[-1])

#adding the combined data to the results 
prog_lthsc_results <- prog_lthsc_results |> 
  left_join(prog_lthsc, by = "ensembl_gene_id")

# this is ensuring points are coloured if FDR < 0.05 and label points with the external gene name if there summary.LogFC is greater than 2.5. 
prog_lthsc_results <- prog_lthsc_results |> 
  mutate(log10_FDR = -log10(FDR),
         sig = FDR < 0.05,
         bigfc = abs(summary.logFC) >= 2.5)     

# Create a data frame for the highlight region
highlight_region <- data.frame(
  xmin = -1.5,
  xmax = 1.5,
  ymin = -Inf,
  ymax = -log10(0.05)
)

vol_prog_lthsc <- prog_lthsc_results |> 
  ggplot(aes(x = summary.logFC, 
             y = log10_FDR, 
             colour = interaction(sig, bigfc))) +
  geom_point(size = 4) +
  geom_hline(yintercept = -log10(0.05), 
             linetype = "dashed") +
  geom_vline(xintercept = 1, 
             linetype = "dashed") +
  geom_vline(xintercept = -1, 
             linetype = "dashed") +
  geom_rect(data = highlight_region, aes(xmin = 1, xmax = 4, ymin = 0, ymax = 41), fill = "darkblue", alpha = 0.15, inherit.aes = FALSE) +
  geom_rect(data = highlight_region, aes(xmin = -5.5, xmax = -1, ymin = 0, ymax = 41), fill = "green", alpha = 0.15, inherit.aes = FALSE) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_colour_manual(values = c("gray",
                                 "pink",
                                 "deeppink")) +
  geom_text_repel(data = subset(prog_lthsc_results, 
                                bigfc & sig),
                  aes(label = external_gene_name),
                  size = 7,
                  max.overlaps = 50, vjust = 0.9, colour = "black") +
  theme_classic() +
  theme(legend.position = "none", 
        axis.title = element_text(size = 30), axis.text = element_text(size = 30),# Adjust the font size for both x and y axis labels
        plot.title = element_text(size = 40, hjust = 0.5),  # Adjust the title font size and center it
        plot.margin = margin(t = 30)) +  # Add margin at the top for the title
  
  ggtitle("Progs vs LT.HSC")

# Save the plot
ggsave("figures/vol_prog_lthsc.png", plot = vol_prog_lthsc, width = 10, height = 6, dpi = 300)
```

```{r}
#creating the combined data set with the ensembl_gene_id as the first column and not the column name: 
lthsc_hspc <- bind_cols(lthsc, hspc[-1])

#adding the combined data to the results 
lthsc_hspc_results <- lthsc_hspc_results |> 
  left_join(lthsc_hspc, by = "ensembl_gene_id")

# Create a data frame for the highlight region
highlight_region <- data.frame(
  xmin = -1.5,
  xmax = 1.5,
  ymin = -Inf,
  ymax = -log10(0.05)
)

# this is ensuring points are coloured if FDR < 0.05 and label points with the external gene name if there summary.LogFC is greater than 2.5. 
lthsc_hspc_results <- lthsc_hspc_results |> 
  mutate(log10_FDR = -log10(FDR),
         sig = FDR < 0.05,
         bigfc = abs(summary.logFC) >= 2)

vol_lthsc_hspc <- lthsc_hspc_results |> 
  ggplot(aes(x = summary.logFC, 
             y = log10_FDR, 
             colour = interaction(sig, bigfc))) +
  geom_point(size = 4) +
  geom_hline(yintercept = -log10(0.05), 
             linetype = "dashed") +
  geom_vline(xintercept = 1, 
             linetype = "dashed") +
  geom_vline(xintercept = -1, 
             linetype = "dashed") +
  geom_rect(data = highlight_region, aes(xmin = 1, xmax = 3, ymin = 0, ymax = 35), fill = "green", alpha = 0.15, inherit.aes = FALSE) +
  geom_rect(data = highlight_region, aes(xmin = -4, xmax = -1, ymin = 0, ymax = 35), fill = "red", alpha = 0.15, inherit.aes = FALSE) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_colour_manual(values = c("gray",
                                 "pink",
                                 "deeppink")) +
  geom_text_repel(data = subset(lthsc_hspc_results, 
                                bigfc & sig),
                  aes(label = external_gene_name),
                  size = 7,
                  max.overlaps = 50, vjust = 0.5, colour = "black") +
  theme_classic() +
  theme(legend.position = "none", 
        axis.title = element_text(size = 30), axis.text = element_text(size = 30),# Adjust the font size for both x and y axis labels
        plot.title = element_text(size = 40, hjust = 0.5),  # Adjust the title font size and center it
        plot.margin = margin(t = 30)) +  # Add margin at the top for the title
  
  ggtitle("HSPC vs LT.HSC")

# Save the plot
ggsave("figures/vol_lthsc_hspc.png", plot = vol_lthsc_hspc, width = 10, height = 6, dpi = 300)
```

```{r}
#| label: fig-volcano-plots
#| fig.cap: "volcano plots depicting the differential expressed genes (DEGs) between progenitors and HSPCs (left panel), between LT.HSCs and HSPCs (middle panel) and between progenitors and LT.HSCs (right panel). The x-axis summarizes the log fold change (logFC) in gene expression, while the y-axis represents the negative log10 of the false discovery rate (FDR). Genes with significant differential expression are highlighted above the horizontal dashed line, indicating a FDR value below 0.05. Genes of the highest summary.logFC are highlighted and labelled. Data analysis was conducted in R (R Core Team 2023) with patchwork, ggrepel and tidyverse packages (Pedersen et al. 2023; Slowikowski et al. 2023; Wickham et al. 2019)"
#| fig.align: "left"
#| fig.width: 25
#| fig.height: 25

# so here we are making a panel wih the three vocano plots: 

# we are making sure all the plots are the same size: 
global_theme <- theme(plot.margin = margin(t = 5, r = 5, b = 20, l = 5, unit = "pt"))
vol_lthsc_hspc <- vol_lthsc_hspc + global_theme
vol_prog_lthsc <- vol_prog_lthsc + global_theme
vol_prog_hspc <- vol_prog_hspc + global_theme

# here we are reducing the size of all the plots. I was having many issues trying to reduce the size of the plots and reducing the apsect ratio was the only way to acheieve this: 
vol_lthsc_hspc <- vol_lthsc_hspc + theme(aspect.ratio = .8)
vol_prog_lthsc <- vol_prog_lthsc + theme(aspect.ratio = .8)
vol_prog_hspc <- vol_prog_hspc + theme(aspect.ratio = .8)

# this combines the plots and ensures two are on the top and one on the bottom: 
panel_volcano_plots <- (vol_lthsc_hspc | vol_prog_lthsc) /
                      (plot_spacer() | vol_prog_hspc | plot_spacer())


# Adjust layout settings
# Here, i am changing the heigths, this again is to solve many issues with getting the plots the same size an having the bottom plot central while having the figure legend not behind the polts: 
panel_volcano_plots <- (vol_lthsc_hspc | vol_prog_lthsc) /
                      vol_prog_hspc +
  plot_layout(heights = c(1, 0.8))

# Display the panel of plots
panel_volcano_plots


```

Next we wanted to be able to visualise the differential gene expression and determine if there is a high level of conistency in gene expression profiles across each cell in all of the cell types. we did this by visualising through a heatmap. The heatmap was generated by combining the raw [Prog](https://joewomersley.github.io/report_quarto/prog_surfaceome.html), [HSPC](https://joewomersley.github.io/report_quarto/hspc_surfaceome.html) and [LT.HSC](https://joewomersley.github.io/report_quarto/lthsc_surfaceome.html) data sets, ensuring they are matched based on ensembl_gene_id. Then we filtered the combined data sets for just the top 20 differentially expressed genes, determined by the differential expression analysis earlier (Table 1). We then added in gene names to this data set and ordered based on the genes summary.LogFC. Clustering the cells based on cell type and visualising though a heatmap, for the top 20 differentially expressed genes indeed shows distinct changes in expression for certain genes between clusters such as, Cd34 and emilin2 @fig-heatmap-celltypes.

```{r}
# so again i am combining the raw data files based on there ensembl_gene_id: 

# Check if the ensembl_gene_id columns are identical
identical_genes_lthsc_hspc <- identical(lthsc$ensembl_gene_id, hspc$ensembl_gene_id)
identical_genes_lthsc_prog <- identical(lthsc$ensembl_gene_id, prog$ensembl_gene_id)

if (identical_genes_lthsc_hspc && identical_genes_lthsc_prog) {
  # Combine the data frames side by side based on ensembl_gene_id
  combined_data <- bind_cols(lthsc[-1], hspc[-1], prog[-1])
  # Set row names to ensembl_gene_id
  row.names(combined_data) <- lthsc$ensembl_gene_id
} else {
  # Handle the case where ensembl_gene_id columns are not identical
  warning("ensembl_gene_id columns are not identical across data frames.")
  # You may want to explore further or handle this case based on your requirements.
}

# List of genes to filter, these are the top 20 differntailly expressed genes from our differential expression analysis. This can be coded directly by taking the genes from top_20_unique_gene_no_duplicates. 
target_genes <- c(
  "ENSMUSG00000027611", # procr
  "ENSMUSG00000054641", # mmrn1
  "ENSMUSG00000001946", # esam
  "ENSMUSG00000015355", # cd48 
  "ENSMUSG00000016494", # cd34
  "ENSMUSG00000038235", # F11r
  "ENSMUSG00000041329", # Atp1b2
  "ENSMUSG00000024053", # Emilin2
  "ENSMUSG00000002808", # Epdr1
  "ENSMUSG00000026748", # Plxdc2
  "ENSMUSG00000030745", # Il21r
  "ENSMUSG00000003420", # Fcgrt 
  "ENSMUSG00000035206", # Sppl2b
  "ENSMUSG00000036594", # H2-Aa
  "ENSMUSG00000022816", # Fstl1
  "ENSMUSG00000021728", # Emb
  "ENSMUSG00000025780", # Itih5
  "ENSMUSG00000059588", # Calcrl
  "ENSMUSG00000031170", # Slc38a5
  "ENSMUSG00000028639") # Ybx1

# Convert row names to a column and filter
filtered_data <- combined_data %>%
  rownames_to_column(var = "ensembl_gene_id") %>%
  filter(ensembl_gene_id %in% target_genes)

rownames(filtered_data) <- filtered_data$ensembl_gene_id

# Create a mapping between ensembl_gene_id and gene names, we added gene names manually but this could have been done using the BiomaRt to connect with the ensembl data base. 
gene_mapping <- data.frame(
  ensembl_gene_id = c(
  "ENSMUSG00000027611", # procr
  "ENSMUSG00000054641", # mmrn1
  "ENSMUSG00000001946", # esam
  "ENSMUSG00000015355", # cd48 
  "ENSMUSG00000016494", # cd34
  "ENSMUSG00000038235", # F11r
  "ENSMUSG00000041329", # Atp1b2
  "ENSMUSG00000024053", # Emilin2
  "ENSMUSG00000002808", # Epdr1
  "ENSMUSG00000026748", # Plxdc2
  "ENSMUSG00000030745", # Il21r
  "ENSMUSG00000003420", # Fcgrt 
  "ENSMUSG00000035206", # Sppl2b
  "ENSMUSG00000036594", # H2-Aa
  "ENSMUSG00000022816", # Fstl1
  "ENSMUSG00000021728", # Emb
  "ENSMUSG00000025780", # Itih5
  "ENSMUSG00000059588", # Calcrl
  "ENSMUSG00000031170", # Slc38a5
  "ENSMUSG00000028639"),
  gene_name = c(
    "procr", "mmrn1", "esam", "cd48", "cd34", "F11r", "Atp1b2", "Emilin2", "Epdr1", "Plxdc2",
    "Il21r", "Fcgrt", "Sppl2b", "H2-Aa", "Fstl1", "Emb", "Itih5", "Calcrl", "Slc38a5", "Ybx1"
  )
)

# Merge the mapping with the filtered_data to replace ensembl_gene_id with gene names
filtered_data_with_names <- merge(filtered_data, gene_mapping, by = "ensembl_gene_id")

# Set row names to gene names
rownames(filtered_data_with_names) <- filtered_data_with_names$gene_name

# This removes the ensembl_gene_id column and gene name column 
expression_data <- filtered_data_with_names[, 3:ncol(filtered_data_with_names)-1] 

# i want to order the data set based on the summary.LogFC from our differential gene analysis (Table1). firstly i am extracting the current gene names in our expression data. 
current_gene_names <- rownames(expression_data)

#now i am creating a vector for the gene_names i read in, in order. 
ordered_gene_names <- gene_mapping$gene_name

# now i am Finding the intersection of ordered_gene_names with current_gene_names to ensure all names exist
valid_ordered_gene_names <- ordered_gene_names[ordered_gene_names %in% current_gene_names]

# now i am matching and ordering the dataframe rows based on valid_ordered_gene_names. This ensures no NAs are introduced, as we're only using gene names that exist in the current data
order_of_rows <- match(valid_ordered_gene_names, current_gene_names)

# THis actually reorder expression_data based on order_of_rows
expression_data <- expression_data[order_of_rows, ]


# Generate a simple annotation for cell types based on column names
cell_type_annotation <- sapply(colnames(expression_data), function(x) strsplit(x, "_")[[1]][1])
unique_cell_types <- unique(cell_type_annotation)
annotation_df <- data.frame(CellType = factor(cell_type_annotation, levels = unique_cell_types))


```

```{r}
#| label: fig-heatmap-celltypes
#| fig.cap: "heatmap showing gene expression of the top 20 differentially expressed genes. Each cell in the heatmap represents the expression level of a gene in a specific cell type. gene expression is displayed on a log2 scale from blue to red (low to high). All 1654 cells are visualised along the X axis and the top 20 differentially expressed genes are shown on the Y axis, as calculated using a statistical model which finds the summary.logFC which is the significance of the difference between the expression in two of the three cell types. Cells were clustered based on cell type; green being LT.HSC, red being HSPC and Progenitors being Blue. Data analysis as conducted in R (R Core Team 2023) with pheatmap and tidyverse packages (Kolde et al. 2019; Wickham et al. 2019)"
#| fig.align: "left" 
#| #| fig.width: 10000
#| fig.height: 5 

# Generate the heatmap with cell type annotations, note one can chnage the cluster rows and cols to TRUE to gain clustering of the data: 
heatmap_celltypes <- pheatmap(expression_data,
         annotation_col = annotation_df, cellheight = 15, 
         cluster_rows = FALSE, 
         cluster_cols = FALSE,
         fontsize_row = 10, # Increased for bigger Y-axis labels
         fontsize_col = 0, # Set to 0 or use labels_col = FALSE to remove X-axis labels
         labels_col = FALSE, # This will remove the column names from the x-axis
         angle_col = 45, # This might be irrelevant now since we're removing column labels
         color = colorRampPalette(c("blue", "white", "red"))(100),
         legend = TRUE,
         legend_size = 50, # Attempt to increase legend text size; note: 'legend_size' isn't a direct pheatmap argument
         show_rownames = TRUE,
         show_colnames = FALSE # Ensure column names are not shown
)

# Save the plot
ggsave("figures/heatmap_celltypes.png", plot = heatmap_celltypes, width = 10, height = 6, dpi = 300)
```

To analyse this further we conducted hierarchical clustering to explore the intrinsic groupings within the data based on gene expression pattern @fig-heatmap-3-celltypes-clustering. This unsupervised technique allowed us to observe natural partitions in the data, allowing us to see if the cells naturally cluster based on cell type. We utilized Ward's method for both column and row clustering, aiming to capture the most informative hierarchical relationships in the dataset. We did this on a subset of data by taking the top 50 differentially expressed genes determined from our differential expression analysis (Table 1), as it allowed for better visualisation. Additionally we ensured that the cells arranged into 4 clusters which allowed easy determination of how the different cell types clustered. The clustering showed that the different cell types did share expression profiles but each cluster did have two of the three cell types within them. However progenitors and LT.HSCs didnt cluster very often indicating a change in gene expression profiles from the progenitor to the LT.HSC. Additionally the genes seemed to naturally fall into 3 clusters, with the most interesting cluster being the middle one which seems to cluster genes that have higher expression in the LT.HSCs and includes a known marker of HSCs, Procr [@balazs2006; @lin2023; @subramaniam2019; @zhou2016].

```{r}
# the code below is for a heatmap for the top 50 differentially expressed genes using hierarchical clustering: 

# Load individual datasets. because now we want the ensembl_gene_ids to be the row: 
prog <- read.csv("data_raw/surfaceome_Prog.csv", row.names = 1)
hspc <- read.csv("data_raw/surfaceome_hspc.csv", row.names = 1)
lthsc <- read.csv("data_raw/surfaceome_lthsc.csv", row.names = 1)


# Combine the datasets into one matrix
# Assuming cells are in columns and genes in rows
combined_data <- cbind(prog, hspc, lthsc)

# Filter combined data for the specified ensembl_gene_id
# Extract the ensembl_gene_id column and create the vector
gene_names <- head(top_differentially_expressed_genes_no_duplicates$external_gene_name, 50)

# Retrieve Ensembl gene IDs based on the external gene names
genes_ensembl_ids <- getBM(attributes = c("external_gene_name", "ensembl_gene_id"),
                    filters = "external_gene_name",
                    values = gene_names,
                    mart = ensembl)

# creating a vector for the top_genes
top_genes <- genes_ensembl_ids$ensembl_gene_id 


#filter the combined data for those genes 
combined_data <- combined_data[top_genes, ]

# Perform hierarchical clustering with complete linkage method for rows
hc_rows <- hclust(dist(combined_data, method = "euclidean"), method = "ward.D2")

# Perform hierarchical clustering with complete linkage method for columns
hc_cols <- hclust(dist(t(combined_data), method = "euclidean"), method = "ward.D2")

# Specify the number of clusters you want to cut the dendrogram into
num_clusters <- 4

# Cut the dendrogram to obtain cluster labels for rows and columns
clusters_rows <- cutree(hc_rows, k = num_clusters)
cluster_cols <- cutree(hc_cols, k = num_clusters)

# Get the order of rows and columns based on clustering
order_rows <- order.dendrogram(as.dendrogram(hc_rows))
order_cols <- order.dendrogram(as.dendrogram(hc_cols))

# Reorder the combined_data based on the clustering
combined_data_reordered <- combined_data[order_rows, order_cols]

# IMPORTANT: Reorder 'cluster_cols' to match the new order of columns in 'combined_data_reordered'
reordered_cluster_cols <- cluster_cols[order_cols]

# Now create annotation_data using the reordered cluster assignments
annotation_data <- data.frame(
  Cell = colnames(combined_data_reordered),  # Use reordered column names
  Cluster = reordered_cluster_cols           # Use reordered cluster assignments
)

# Create CellType column by removing anything after "_" in the cell names
annotation_data$CellType <- sub("_.*", "", annotation_data$Cell)

# Define custom colors for the clusters
cluster_colors <- c("purple", "cyan", "orange", "deeppink")  # Example custom colors

CellType_colors <- c('Prog' = 'blue', 'LT.HSC' = 'green', 'HSPC' = 'red')

# Sort annotation_data by Cluster and then by CellType within each Cluster
annotation_data_sorted <- annotation_data %>%
  arrange(Cluster, CellType, Cell)

# Use the sorted annotation_data to define the new column order for combined_data_reordered
new_col_order <- match(annotation_data_sorted$Cell, colnames(combined_data_reordered))

# Apply this new column order to combined_data_reordered
combined_data_final <- combined_data_reordered[, new_col_order]

#removing the cell column so is doesnt assign every cell a colour in our heatmap:
annotation_data_sorted <- subset(annotation_data_sorted, select = -c(Cell))

# Loop over each row name in combined_data_final
for (i in seq_along(rownames(combined_data_final))) {
    # Find the matching gene name for the current Ensembl ID
    matched_gene_name <- genes_ensembl_ids$external_gene_name[match(rownames(combined_data_final)[i], genes_ensembl_ids$ensembl_gene_id)]
    
    # Update the row name if a match is found
    if (!is.na(matched_gene_name)) {
        rownames(combined_data_final)[i] <- matched_gene_name
    }
    # If no match is found, do nothing, leaving the Ensembl ID as the row name
}
```

```{r}
#| label: fig-heatmap-3-celltypes-clustering
#| fig.cap: "heatmap showing gene expression of the top 50 differentially expressed genes. Each cell in the heatmap represents the expression level of a gene in a specific cell type. gene expression is displayed on a log2 scale from blue to red (low to high). All 1654 cells are visualised along the X axis and the top 50 differentially expressed genes are shown on the Y axis, as calculated using a statistical model which finds the summary.logFC which is the significance of the difference between the expression in two of the three cell types. Both the genes and cells were clustered using the ward method. The genes were clustered with no supervision whereas the cells were arranged into four clusters for better visual patterns in their gene expression. Data analysis as conducted in R (R Core Team 2023) with biomaRt, pheatmap and tidyverse packages (Durinck et al. 2009; Kolde et al. 2019; Wickham et al. 2019)"
#| fig.align: "left" 
#| fig.height: 5 
# Generate the heatmap with clustering but without showing dendrograms
heatmap_3_celltypes_clustering <- pheatmap(
  combined_data_final, cellheight = 5.7,
  cluster_rows = FALSE,   # Do Not Cluster rows, we have already ordered the rows based on the clustering 
  cluster_cols = FALSE,  # Do not cluster columns,  we have already ordered the columns based on the clustering. 
  show_rownames = TRUE,  # Show row names
  show_colnames = FALSE,  # Do not show column names
  fontsize_row = 6,
  fontsize_col = 6,
  angle_col = 45,
  color = colorRampPalette(c("blue", "white", "red"))(100),
  legend = TRUE,
  annotation_col = annotation_data_sorted,
  treeheight_row = 5,     # Hide dendrogram lines for rows
  treeheight_col = 5,     # Hide dendrogram lines for columns
  annotation_colors = list(CellType = CellType_colors, Cluster = cluster_colors)  # Specify custom colors for the cluster annotations
)

# Save the plot
ggsave("figures/heatmap_3_celltypes_clustering.png", plot = heatmap_3_celltypes_clustering, width = 10, height = 6, dpi = 300)
```

Another common way of being able to visual patterns in larges data sets is using a principle commonent analysis which reduces the high-dimensional gene expression data into few principal components ([@ringnér2008]). we peformed a principle commonent analysis on our combined dataset and took the first three principle components to generate a 3D PCA plot @Fig-3D-PCA-3-celltypes. This again showed distinct gene expression profiles for the 3 cell types and indicated differential expression of genes corresponding with the different cell types.

```{r}

# before we filtered the combined data so we must now generate a new combined data set: 
combined_data <- cbind(prog, hspc, lthsc)

# Transpose the data to have cells in rows and genes in columns: 
combined_data <- t(combined_data)

# Perform PCA:
normalized_data <- scale(combined_data)

pca_result <- prcomp(normalized_data, scale. = TRUE)

# Create a data frame with PCA results:
pca_data <- as.data.frame(pca_result$x)

# Assign cell type information: 
cell_types <- c(rep("Prog", ncol(prog)))
cell_types <- c(cell_types, rep("HSPC", ncol(hspc)))
cell_types <- c(cell_types, rep("LTHSC", ncol(lthsc)))

# # Add the cell_type variable to pca_data --------------------------------
pca_data$cell_type <- cell_types

# Assign a neutral color for baseline expression to all cells
pca_data$Color <- 'grey'  

# Define colors for each cell type
cell_type_colors <- c("Prog" = "blue", "HSPC" = "red", "LTHSC" = "green")

# Prepare the initial 3D PCA plot with all cells in grey to represent baseline expression
plot_3d_pca_cell_types <- plot_ly(data = pca_data, x = ~PC1, y = ~PC2, z = ~PC3, type = 'scatter3d', mode = 'markers',
                                  marker = list(color = ~Color, size = 4, opacity = 0.5),  # Use the baseline color
                                  name = "Baseline Expression") %>%
  layout(title = "3D PCA Plot Highlighting Cell Types",
         scene = list(xaxis = list(title = "PC1"),
                      yaxis = list(title = "PC2"),
                      zaxis = list(title = "PC3")),
         legend = list(title = list(text = 'Cell Types'), orientation = "h"))

# Loop over each cell type and overlay their specific colors
for(cell_type in names(cell_type_colors)) {
  cells_of_type <- pca_data$cell_type == cell_type
  plot_3d_pca_cell_types <- plot_3d_pca_cell_types %>%
    add_trace(data = pca_data[cells_of_type, ], x = ~PC1, y = ~PC2, z = ~PC3,
              type = 'scatter3d', mode = 'markers',
              marker = list(color = cell_type_colors[cell_type], size = 4, opacity = 0.8),
              name = cell_type)
}

```

```{r}
#| label: fig-3D-PCA-3-celltypes
#| fig.cap: "3D PCA plot of cell surface protein expression profiles across LTHSC (Green), HSPC (Red) and Progenitor (Blue) cell types. The PCA was performed on normalised log2 expression data of surfaceome genes, whereby each dot represents a single cell and projected based on its surfaceome gene expression profile through the first three principle components (PC1, PC2 and PC3). To interact with the plot, use the figure legend which is interactive whereby you can click on each cell type to view them and the baseline allows the visualisation of each cell type in the context of ll the other cells. Data analysis as conducted in R (R Core Team 2023) with the plotly package (sievert et al. 2020)"
#| fig.align: "left" 
#| fig.height: 5 
# Display the plot, the oriantation allows for the interative figure legend be on the side.  
plot_3d_pca_cell_types <- plot_3d_pca_cell_types %>%
  layout(autosize = F, height = 450, width = 800, # Adjust size as needed
         legend = list(orientation = "v",  font = list(size = 18)))


plot_3d_pca_cell_types

# to save the PCA plot its abit more complicated, i struggled to save as a webshot and found that if one want to get a static image of the 3D PCA plot, save as a HTML, open it in a browser, adjust the plot to the specific orintation you desire and screenshot it, this won't be the best quality but allows for the flexability. 
htmlwidgets::saveWidget(plot_3d_pca_cell_types, "figures/HTML_files/plot_3d_pca_cell_types.html", selfcontained = TRUE)

```

We have previously determined the top differentially expressed genes and shown that cellls tend to cluster based on cell type and that there is defined gene expression profiles for each of the cell types. To determine if genes expressions mapped that of specific cell types we used the same 3D PCA plot but highlighted cells where expression of 12 of the top differentially expressed genes where greater than 3 @fig-3D-PCA-top-genes. This clearly showed that genes that are highly differentially expressed tended to have the same expression profile of distinct cell types.

```{r}
# so we are making a 3D PCA where we can see the expression profile of the top 12 differentially expressed genes: 
genes_of_interest <- head(top_differentially_expressed_genes_no_duplicates$external_gene_name, 12)

# Retrieve Ensembl gene IDs based on the external gene names
genes_of_interest <- getBM(attributes = c("external_gene_name", "ensembl_gene_id"),
                    filters = "external_gene_name",
                    values = genes_of_interest,
                    mart = ensembl)
# assigning the colour for our cells with high expression of specfic genes: 
genes_of_interest$Color <- 'red'

 # Expression threshold
  threshold <- 3
  
  # Initialize all cells to be grey, then overlay with colors for high expressions, so we have a baseline expression: 
  pca_data$Color <- 'grey' 
  
  # Prepare the initial 3D PCA plot with all cells in grey
  plot_3d_pca_genes <- plot_ly(pca_data, x = ~PC1, y = ~PC2, z = ~PC3, type = 'scatter3d', mode = 'markers',
                               marker = list(size = 4, color = 'grey', opacity = 0.5), # Set opacity for the grey background cells
                               name = "Baseline Expression") %>%
    layout(title = "3D PCA Plot Highlighting Gene Expression",
           scene = list(xaxis = list(title = "PC1"),
                        yaxis = list(title = "PC2"),
                        zaxis = list(title = "PC3")),
           legend = list(title = list(text = 'Gene Expression'), orientation = "h"))
  
  # Loop to overlay high expression cells in their respective colors
  for(i in 1:nrow(genes_of_interest)) {
    gene_id <- genes_of_interest$ensembl_gene_id[i]
    # Determine high expression for the current gene
    high_expr <- combined_data[, gene_id] > threshold
    pca_data$Color[high_expr] <- genes_of_interest$Color[i]
    
    # Add trace for high expression of the current gene
    plot_3d_pca_genes <- plot_3d_pca_genes %>%
      add_trace(data = pca_data[high_expr, ], x = ~PC1, y = ~PC2, z = ~PC3,
                type = 'scatter3d', mode = 'markers',
                name = genes_of_interest$external_gene_name[i],
                marker = list(size = 4, color = genes_of_interest$Color[i], opacity = 0.8),
                showlegend = TRUE)
  }
  

```

```{r}
#| label: fig-3D-PCA-top-genes
#| fig.cap: "3D PCA analysis showing cells highlighted with high expression of the top 12 differentially expressed genes. Cells are highlighted in red when absolute expression of that gene is greater than 3. Data analysis as conducted in R (R Core Team 2023) with the biomaRt and plotly packages (Durinck et al. 2009; sievert et al. 2020)"
#| fig.align: "left" 
  # Display the plot
  plot_3d_pca_genes %>%
  layout(legend = list(autosize = F, height = 450, width = 800, orientation = "v", font = list(size = 18)))
  
#save as a HTML   
htmlwidgets::saveWidget(plot_3d_pca_genes, "figures/HTML_files/plot_3d_pca_genes.html", selfcontained = TRUE)
```

From viewing these 12 genes in the context of the 3D PCA Plots, we identified Mmrn1 as a good candidate for a marker of LT.HSCs. It clearly show that high Mmrn1 gene expression follows a very similar pattern of expression that overlaps with the LT.HSC population. Additionally, we have shown it to be highly differentially expressed through volcano plots in the LT.HSC population @fig-volcano-plots and it can be seen through our heatmap plot there is a gradual increase in its expression going from the Progenitor population through the HSPCs and into the LT.HSC population @fig-heatmap-celltypes. Additionally, when we peformed heicharcial clustering Mmrn1 clustered near to procr which is a known marker of HSCs [@balazs2006; @lin2023; @subramaniam2019; @zhou2016]. We performed a 3D PCA comparing Procr and Mmrn1 expression. This showed expression levels across the entire population of cells whereby high expression is yellow and low expression dark blue @fig-3D-PCA-Mmrn1-Procr . The 3D PCA clearly shows both to have very similar expression across the cell types and hence is another good indication that Mmrn1 might be a good marker of LT. HSCs and worth exploring further.

```{r}
# re-defining the combined data set 
combined_data <- cbind(Prog = prog, HSPC = hspc, LTHSC = lthsc)

#transposing the data set
combined_data <- t(combined_data)

# defining our gene of interest, Procr in this case
gene_of_interest <- 'ENSMUSG00000027611'  

# Filter cells with high expression of the gene of interest in the datasets
threshold_value <- 3.0  

# Identify cells expressing the gene of interest at a high level
gene_expression <- combined_data[, gene_of_interest]  

# Define a color scale for the gene expression gradient
color_scale <- colorRamp(c("white", "purple")) 

# Normalising the gene expression values to use them in the color gradient
normalized_expression <- gene_expression
normalized_expression <- (normalized_expression - min(normalized_expression)) / (max(normalized_expression) - min(normalized_expression))

# Create a data frame including the normalized gene expression
pca_data$Expression <- normalized_expression


# Update the plot code to incorporate the gene expression colors as a gradient
plot_3D_PCA_Procr <- plot_ly(data = pca_data) %>%
  add_trace(x = ~PC1, y = ~PC2, z = ~PC3,
            type = 'scatter3d', mode = 'markers',
            marker = list(size = 4, color = ~Expression, colorscale = 'Viridis', showscale = FALSE)) %>%
  layout(scene = list(aspectmode = "cube"), title = "Procr")

#save as a HTML   
htmlwidgets::saveWidget(plot_3D_PCA_Procr, "figures/HTML_files/plot_3D_PCA_Procr.html", selfcontained = TRUE)
```

```{r}
# doing the same as above but for mmrn1

# re-defining the combined data set 
combined_data <- cbind(Prog = prog, HSPC = hspc, LTHSC = lthsc)

#transposing the data set
combined_data <- t(combined_data)

# defining our gene of interest, mmrn1 in this case
gene_of_interest <- 'ENSMUSG00000054641'  

# Filter cells with high expression of the gene of interest in the datasets
threshold_value <- 3.0  

# Identify cells expressing the gene of interest at a high level
gene_expression <- combined_data[, gene_of_interest]  

# Define a color scale for the gene expression gradient
color_scale <- colorRamp(c("white", "purple")) 

# Normalising the gene expression values to use them in the color gradient
normalized_expression <- gene_expression
normalized_expression <- (normalized_expression - min(normalized_expression)) / (max(normalized_expression) - min(normalized_expression))

# Create a data frame including the normalized gene expression
pca_data$Expression <- normalized_expression

plot_3D_PCA_mmrn1 <- plot_ly(data = pca_data) %>%
  add_trace(x = ~PC1, y = ~PC2, z = ~PC3,
            type = 'scatter3d', mode = 'markers',
            marker = list(size = 4, color = ~Expression, colorscale = 'Viridis', showscale = FALSE)) %>%
  layout(scene = list(aspectmode = "cube"), title = "Mmrn1")

#save as a HTML   
htmlwidgets::saveWidget(plot_3D_PCA_mmrn1, "figures/HTML_files/plot_3D_PCA_mmrn1.html", selfcontained = TRUE)

# below is some quite complex code. becuase Plotly doesnt allow plots to be placed next to each other like the plots above, we have had to use some work arounds so we have read in the plots and used the layout-ncol function to place them next to each other. THe CSS style further customizes the layout. It uses Flexbox to ensure that the plots are evenly spaced (justify-content: space-around;), vertically centered (align-items: center;), and can wrap onto multiple lines if needed (flex-wrap: wrap;). This style provides flexibility and ensures that the plots look good regardless of the screen size.
```

::: {#fig-3D-PCA-Mmrn1-Procr layout-ncol="2" style="display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap;"}
```{r, echo=FALSE, message=FALSE, fig.align='center'}
#| label: fig-PCA_plot_mmrn1
#| fig-cap: Mmrn1 3D PCA Plot

plot_3D_PCA_mmrn1 <- plot_3D_PCA_mmrn1 %>%
  layout(margin = list(l = 25, r = 25, b = 35, t = 35),
         width = 400, height = 400)


plot_3D_PCA_mmrn1
```

```{r, echo=FALSE, message=FALSE, fig.align='center'}
#| label: fig-PCA_plot_Procr
#| fig-cap: Procr 3D PCA Plot
plot_3D_PCA_Procr <- plot_3D_PCA_Procr %>%
  layout(margin = list(l = 25, r = 25, b = 35, t = 35),
         width = 400, height = 400)


plot_3D_PCA_Procr
```

3D PCA plots show gene expression levels of mmrn1 (a) and Procr (b). The PCA was performed on normalised log2 expression data of surfacesome genes. Each dot represents a single cell and projected based on its surfacesome gene expression profile through the first three principle components (PC1, PC2 and PC3). Colours from yellow to blue indicates high to low expression. The plots showing high similarity between Procr and Mmrn1. Data analysis as conducted in R (R Core Team 2023) with the biomaRt and plotly packages (Sievert et al. 2020)"
:::

To analyse Mmrn1 expression further we averaged its expression corresponding to each cell type. We were able to show that the log2 absolute expression is highest in LT.HSC with an average expression of 5.035 followed by some expression in the HSPC population with average expression of 2.840 and very little expression seen in the progenitor population with just an average expression of 0.891 @fig-Mmrn1_expression_plot.

```{r}
#now we want to create a bar graph showing average Mmrn1 expression across the three cell types

# Function to calculate standard error
calc_se <- function(x) {
  sd_x <- sd(x)
  n_x <- length(x)
  se_x <- sd_x / sqrt(n_x)
  return(se_x)
}

# Function to generate summary statistics for a gene
summary_data_mmrn1 <- function(mmrn1, lthsc, hspc, prog) {
  # Extract gene values using row names
  gene_vals_lthsc <- as.numeric(lthsc[rownames(lthsc) == mmrn1, ])
  gene_vals_hspc <- as.numeric(hspc[rownames(hspc) == mmrn1, ])
  gene_vals_prog <- as.numeric(prog[rownames(prog) == mmrn1, ])

  # Remove NA values
  gene_vals_lthsc <- gene_vals_lthsc[!is.na(gene_vals_lthsc)]
  gene_vals_hspc <- gene_vals_hspc[!is.na(gene_vals_hspc)]
  gene_vals_prog <- gene_vals_prog[!is.na(gene_vals_prog)]

  # Calculate summary statistics
  summary_stats <- data.frame(
    cell_type = c("LT.HSC", "HSPC", "Prog"),
    mean = c(mean(gene_vals_lthsc), mean(gene_vals_hspc), mean(gene_vals_prog)),
    std = c(sd(gene_vals_lthsc), sd(gene_vals_hspc), sd(gene_vals_prog)),
    n = c(length(gene_vals_lthsc), length(gene_vals_hspc), length(gene_vals_prog))
  )

  # Calculate standard error
  summary_stats$se <- sapply(list(gene_vals_lthsc, gene_vals_hspc, gene_vals_prog), calc_se)

  return(summary_stats)
}

# defining our gene of interest 
mmrn1 <- "ENSMUSG00000054641"

# Generate summary statistics for the specified gene ID
gene_summary <- summary_data_mmrn1(mmrn1, lthsc, hspc, prog)

# Define the order of cell types
cell_type_order <- c("LT.HSC", "HSPC", "Prog")

# Convert cell_type to factor with the specified order
gene_summary$cell_type <- factor(gene_summary$cell_type, levels = cell_type_order)

```

```{r}
# to make a bar plot we first need to determine if the values of mean expression for each cell types are signifcantly different. We cannot determine this with the current gene summary data. so first we need to combine the raw data files but only for the gene Mmrn1. 

# Extract Mmrn1 expression data for each cell type
mmrn1_lthsc <- as.numeric(lthsc["ENSMUSG00000054641", ])
mmrn1_hspc <- as.numeric(hspc["ENSMUSG00000054641", ])
mmrn1_prog <- as.numeric(prog["ENSMUSG00000054641", ])

# Combine into a single data frame with appropriate labels
mmrn1_data <- data.frame(
  expression = c(mmrn1_lthsc, mmrn1_hspc, mmrn1_prog),
  cell_type = factor(rep(c("LT.HSC", "HSPC", "Prog"), 
                         times = c(length(mmrn1_lthsc), length(mmrn1_hspc), length(mmrn1_prog))))
)

# we next need to see if the average expression of mmrn1 across the cell types are significantly different: 

#conduct an anova test
anova_result <- aov(expression ~ cell_type, data = mmrn1_data)

#conduct a turkey test to see P.values for the comparisons 
tukey_result <- TukeyHSD(anova_result)

# Extract the results into a data frame for easier manipulation
tukey_df <- as.data.frame(tukey_result$cell_type)

# Format and print the adjusted p-values with increased precision, so we can see the exact P.values
tukey_df$p.adj.formatted <- formatC(tukey_df$`p adj`, format = "f", digits = 40)

```

```{r}
#| label: fig-Mmrn1_expression_plot
#| fig-cap: "average expression of Mmrn1 across LT.HSC, HSPC and Progenitor populations as determined using single cell RNA sequencing of 1,654 individual cells (155 LT-HSCs, 701 HSPCs, 798 Progs). Data analysis was conducted in R (R Core Team 2023) with tidyverse packages (Wickham et al. 2019)." 

Mmrn1_expression_plot <- ggplot(gene_summary, aes(x = cell_type, y = mean)) + geom_bar(aes(x = cell_type, y = mean, fill = cell_type), stat = "identity", width = 0.6) + 
  geom_point(position = position_dodge(width = 0.5), size = 1.5) +  # Add points for means
  geom_errorbar(aes(ymin = mean - se, ymax = mean + se), width = 0.1, position = position_dodge(width = 0.5), size = 0.5) +  # Error bars
  labs(
    y = "Gene expression",
    title = paste("Expression of Mmrn1 across cell types")
  ) +
  scale_fill_manual(values = c("green", "red", "blue")) +  # Set different colors for the bars
  theme_classic() +
  theme(axis.title.x = element_blank()) +
  theme(plot.title = element_text(hjust = 0.5)) + theme(
    plot.title = element_text(hjust = 0.5, vjust = 1, size = 20),
    axis.text = element_text(size = 15),
    axis.title = element_text(size = 20), legend.title = element_text(size = 15), legend.text = element_text(size = 12), plot.margin = margin(t = 10, r = 10, b = 20, l = 10, unit = "pt")) + annotate("text", x = 1, y = 5.5 , label = "5.035", size = 5) +
  annotate("text", x = 2, y = 3.15, label = "2.840", size = 5) +
  annotate("text", x = 3, y = 1.15, label = "0.891", size = 5) + 
  annotate("text", x = 1.5, y = 6 , label = "****", size = 6) +
  annotate("text", x = 2, y = 7, label = "****", size = 6) +
  annotate("text", x = 2.5, y = 6.5, label = "****", size = 6)+
  annotate("segment", x = 1, xend = 3, y = 7, yend = 7, colour = "black", size = 0.5) + 
  annotate("segment", x = 1, xend = 1, y = 7, yend = 6.7, colour = "black", size = 0.5) + 
  annotate("segment", x = 3, xend = 3, y = 7, yend = 6.7, colour = "black", size = 0.5) + 
  annotate("segment", x = 1, xend = 2, y = 6, yend = 6, colour = "black", size = 0.5) +
  annotate("segment", x = 1, xend = 1, y = 6, yend = 5.7, colour = "black", size = 0.5) + 
  annotate("segment", x = 2, xend = 2, y = 6, yend = 5.7, colour = "black", size = 0.5)  +
  annotate("segment", x = 2, xend = 3, y = 6.5, yend = 6.5, colour = "black", size = 0.5) +  
  annotate("segment", x = 2, xend = 2, y = 6.5, yend = 6.2, colour = "black", size = 0.5) + 
  annotate("segment", x = 3, xend = 3, y = 6.5, yend = 6.2, colour = "black", size = 0.5)  

Mmrn1_expression_plot

# Save the plot
ggsave("figures/Mmrn1_expression_plot.png", plot = Mmrn1_expression_plot, width = 10, height = 6, dpi = 300)
```

To analyse Mmrn1 expression further we utilised sub-population data which takes the original Progenitor and HSPC populations and further defines them into [sub-populations](https://joewomersley.github.io/report_quarto/dt_er_cell_types.html) using index sorting data based on flow cytometry markers [@nestorowa2016]. One might notice that the original cells now fit multiple definitions. To circumvent this issue we set up a a prioritisation logic, which assigns a priority ranking: 1st LTHSC, 2nd MPP, 3rd MPP1-3, 4th STHSC, then the function prioritises randomly if the new definitions don't fit any of the logic laid out previously, but notably prioritises non-broad cells over broad cells. so, this prioritises cell types deemed most important for the analysis and also excludes broad cells. We then applied this logic to our data set and filtered it for just Mmrn1 expression and determined mmrn1 expression across the sub-population data @fig-Mmrn1_expression_subpop_plot. It clearly showed again that expression of mmrn1 had this relation with stemness with highest expression being in the LT. HSCs (5.149), then the MPP population (3.102), LMPP (1.635), CMP (1.016), GMP (0.668), MEP (0.651).

```{r}
#writing in the sub-population data
er_cell_types <- read.csv("sub_population_data/er_cell_types.csv")

#writing as a html to be uploaded to github so a URL can be made so the reader can be shown the data in the render

# Create interactive DT tables for each dataset
dt_er_cell_types <- datatable(er_cell_types, options = list(pageLength = 10, searchHighlight = TRUE))

# Save the DT tables as HTML files
saveWidget(dt_er_cell_types , "sub_population_data/HTML/dt_er_cell_types.html", selfcontained = TRUE)

```

```{r}
# in this code we want to find the averageexpression of mmrn1 across the sub-population cell types: 

# combiing the raw data again: 
 combined_data <- bind_cols(lthsc, hspc, prog)
 
# Create a new data frame with the row names as the first column
combined_data <- data.frame(ensembl_gene_id = rownames(combined_data), combined_data)

# Reset the row names of the new data frame to NULL (optional)
rownames(combined_data) <- NULL

# Prepare the er_cell_types dataframe for easier merging
# Assuming we want to map each cell to its most specific non-zero sub-type
er_cell_types_long <- pivot_longer(er_cell_types, cols = -cell, names_to = "cell_type", values_to = "value") %>%
  filter(value == 1) %>%
  select(-value)

# Function to prioritize cell types
prioritize_cell_type <- function(cell_type) {
  priority_rank <- case_when(
    grepl("LTHSC$", cell_type) & !grepl("_broad", cell_type) ~ 1,
    grepl("^MPP$", cell_type) ~ 2,
    grepl("MPP[0-9]$", cell_type) ~ 3,
    grepl("STHSC$", cell_type) & !grepl("_broad", cell_type) ~ 4,
    TRUE ~ 5  # Default priority for unspecified types or broad types
  )
  return(priority_rank)
}

# Apply prioritization logic
er_cell_types_long_prioritised <- er_cell_types_long %>%
  mutate(priority_rank = sapply(cell_type, prioritize_cell_type)) %>%
  arrange(cell, priority_rank, cell_type) %>%
  group_by(cell) %>%
  slice(1) %>%
  ungroup() %>%
  select(-priority_rank)  # Remove the priority rank column after sorting

# Filter for the specific gene 'ENSMUSG00000054641'
gene_expression <- combined_data %>%
  filter(ensembl_gene_id == 'ENSMUSG00000054641') %>%
  select(-ensembl_gene_id) %>%
  t() %>%
  as.data.frame()

# Name the columns appropriately
colnames(gene_expression) <- 'ENSMUSG00000054641'
gene_expression$cell <- rownames(gene_expression)

# Merge with the main data frame
er_cell_types_long_prioritised <- er_cell_types_long_prioritised %>%
  left_join(gene_expression, by = "cell")

# Create the 'new_cell' column which is just the cells but removing the numberical identifyer by taking the unique cell naming and removing the numbering: 
er_cell_types_long_prioritised$new_cell <- paste(er_cell_types_long_prioritised$cell_type, sub(".*_(\\d+)$", "\\1", er_cell_types_long_prioritised$cell), sep = "_")

# Filter out cell types ending with '_broad', ESLAM, HSC1 and projected cells: 
filtered_er_cell_types_long_prioritised <- er_cell_types_long_prioritised %>%
  filter(
    !grepl('_broad$', cell_type),
    !grepl('ESLAM', cell_type),
    !grepl('HSC1', cell_type),
    !grepl('Projected', cell_type)
  )

# Calculate mean and SEM for each cell type, excluding '_broad'
average_expression_with_sem_filtered <- filtered_er_cell_types_long_prioritised %>%
  group_by(cell_type) %>%
  summarise(Average_Expression = mean(ENSMUSG00000054641, na.rm = TRUE),
            SEM = sd(ENSMUSG00000054641, na.rm = TRUE) / sqrt(n()))


```

```{r}
#| label: fig-Mmrn1_expression_subpop_plot
#| fig-cap: "average expression of Mmrn1 across the sub-population data. Doing so using the same single cell RNA sequecing data seen in figure 10, but redefining the 3 cell types (LT.HSC, HSPC, Prog) into 6 sub-populations (CMP, GMP, LMPP, LT.HSC, MEP, MPP) as defined using flow cytometry markers and broad gating defined In the Nesterowa et al paper. Data analysis was conducted in R (R Core Team 2023) with tidyverse packages (Wickham et al. 2019)." 


# Plotting with error bars and customized theme
Mmrn1_subpop_plot <- ggplot(average_expression_with_sem_filtered, aes(x = cell_type, y = Average_Expression, fill = cell_type)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = c("purple", "darkgreen", "lightblue", "green", "orange", "red")) +  
  geom_errorbar(aes(ymin = Average_Expression - SEM, ymax = Average_Expression + SEM), width = .2) +
  theme_minimal() +
  theme(
    plot.background = element_blank(), # Remove background
    panel.background = element_blank(), # Remove panel background
    panel.grid.major = element_blank(), # Remove major grid lines
    panel.grid.minor = element_blank(), # Remove minor grid lines
    axis.line = element_line(color = "black"), # Strong lines for X and Y axis
    axis.title.x = element_text(size = 0, face = "bold"), # we dont need an X title, but we have left it in if your data need one and for easy manipulation
    axis.title.y = element_text(size = 20, face = "bold"), # Bigger and bolder Y axis title
    axis.text.x = element_text(angle = 0, hjust = 0.5, size = 15), # Bigger X axis labels
    axis.text.y = element_text(size = 15), # Bigger Y axis labels
    plot.title = element_text(hjust = 0.5, size = 20), # Center and increase size of the title
    legend.title = element_text(size = 15), # Corrected legend title size
    legend.text = element_text(size = 12) # Corrected legend text size
  ) +
  labs(x = "Cell Type", y = "Average Expression", title = "Expression of Mmrn1 Across Sub-populations") +
  scale_y_continuous(limits = c(NA, 8)) + 
  annotate("segment", x = 1, xend = 4, y = 8, yend = 8, colour = "black", size = .5) + 
  annotate("segment", x = 4, xend = 2, y = 6.5, yend = 6.5, colour = "black", size = .5) +
  annotate("segment", x = 4, xend = 3, y = 7.0, yend = 7.0, colour = "black", size = .5) +  
  annotate("segment", x = 4, xend = 6, y = 7.5, yend = 7.5, colour = "black", size = .5) +  
  annotate("segment", x = 4, xend = 5, y = 6, yend = 6, colour = "black", size = .5) +   
  annotate("text", x = 2.5, y = 8, label = "****", size = 6) +
  annotate("text", x = 5, y = 7.5, label = "****", size = 6) +
  annotate("text", x = 3.5, y = 7, label = "****", size = 6) +
  annotate("text", x = 3, y = 6.5, label = "****", size = 6) +
  annotate("text", x = 4.5, y = 6, label = "****", size = 6) +
  annotate("text", x = 1, y = 1.4, label = "1.016", size = 5) +
  annotate("text", x = 2, y = 1.1, label = "0.668", size = 5) + 
  annotate("text", x = 3, y = 2.05, label = "1.635", size = 5) +
  annotate("text", x = 4, y = 5.6, label = "5.149", size = 5) +
  annotate("text", x = 5, y = 1, label = "0.651", size = 5) +
  annotate("text", x = 6, y = 3.6, label = "3.102", size = 5)

Mmrn1_subpop_plot

# Save the plot
ggsave("figures/Mmrn1_subpop_plot.png", plot = Mmrn1_subpop_plot, width = 10, height = 6, dpi = 300)
```

To explore the high mmrn1 exression that is seen in the MPP population we further defined it into MPP1, MPP2, MPP3 and generic MPP (when cells don't fit within the gating for any of the sub-populations of MPP but fit within the wider gating) By using index sorting data based on flow cytometry markers [@nestorowa2016] @fig-Mmrn1_expression_subpop_MPP_plot. Interestingly this showed expression of mmrn1 within the MPP sub-population differed greatly. The generic MPP population still saw a similar expression of 3.614, however the MPP1 population had high expression of 4.971 which was not significantly different from that of the LT. HSC. MPP2 and MPP3 showed a great reduction in expression of Mmrn1 with expression being 1.558 and 1.329 respectively.

```{r}
# we are editing our prioritisation logic to see mmrn1 expression across the MPP sub-populations and LT.HSC population: 

# Revised function to prioritize cell types
prioritize_cell_type <- function(cell_type) {
  priority_rank <- case_when(
    grepl("LTHSC$", cell_type) & !grepl("_broad", cell_type) ~ 1,
    grepl("^MPP[0-9]$", cell_type) ~ 2,
    grepl("MPP$", cell_type) ~ 3,
    grepl("STHSC$", cell_type) & !grepl("_broad", cell_type) ~ 4,
    TRUE ~ 5  # Default priority for unspecified types or broad types
  )
  return(priority_rank)
}

# Apply the revised prioritization logic
er_cell_types_long_prioritised_different <- er_cell_types_long %>%
  mutate(priority_rank = sapply(cell_type, prioritize_cell_type)) %>%
  arrange(cell, priority_rank, cell_type) %>%
  group_by(cell) %>%
  slice(1) %>%
  ungroup() %>%
  select(-priority_rank)  # Remove the priority rank column after sorting

# Filter for the specific gene 'ENSMUSG00000054641'
gene_expression <- combined_data %>%
  filter(ensembl_gene_id == 'ENSMUSG00000054641') %>%
  select(-ensembl_gene_id) %>%
  t() %>%
  as.data.frame()

# Name the columns appropriately
colnames(gene_expression) <- 'ENSMUSG00000054641'
gene_expression$cell <- rownames(gene_expression)

# Merge with the main data frame
er_cell_types_long_prioritised_different <- er_cell_types_long_prioritised_different %>%
  left_join(gene_expression, by = "cell")

# Create the 'new_cell' column
er_cell_types_long_prioritised_different$new_cell <- paste(er_cell_types_long_prioritised_different$cell_type, sub(".*_(\\d+)$", "\\1", er_cell_types_long_prioritised_different$cell), sep = "_")

# Filter out cell types ending with '_broad' and other cell types apart from the LTHSCs and MPPs
filtered_er_cell_types_long_prioritised_different <- er_cell_types_long_prioritised_different %>%
  filter(!(cell_type %in% c('LMPP', 'CMP', 'GMP', 'MEP', 'ESLAM')) & !grepl('_broad$', cell_type))

# Calculate mean and SEM for each cell type, excluding '_broad'
average_expression_with_sem_filtered_new <- filtered_er_cell_types_long_prioritised_different %>%
  group_by(cell_type) %>%
  summarise(Average_Expression = mean(ENSMUSG00000054641, na.rm = TRUE),
            SEM = sd(ENSMUSG00000054641, na.rm = TRUE) / sqrt(n()))


```

```{r}
#| label: fig-Mmrn1_expression_subpop_MPP_plot
#| fig-cap: "average expression of Mmrn1 across the MPP sub-populations and LT.HSC population. Doing so using the same single cell RNA sequencing data seen in figure 10 but only visualising LTHSCs and redefining the MPP population further to MPP1, MPP2 and MPP3 where by any cells that has not been able to be further refined are still considered generic MPPs. Data analysis was conducted in R (R Core Team 2023) with tidyverse packages (Wickham et al. 2019)." 

Mmrn1_subpop_MPP_plot <- ggplot(average_expression_with_sem_filtered_new, aes(x = cell_type, y = Average_Expression, fill = cell_type)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = c("green", "red", 'deeppink', "pink", 'violet')) +  
  geom_errorbar(aes(ymin = Average_Expression - SEM, ymax = Average_Expression + SEM), width = .2) +
  theme_minimal() +
  theme(
    plot.background = element_blank(), # Remove background
    panel.background = element_blank(), # Remove panel background
    panel.grid.major = element_blank(), # Remove major grid lines
    panel.grid.minor = element_blank(), # Remove minor grid lines
    axis.line = element_line(color = "black"), # Strong lines for X and Y axis
    axis.title.x = element_text(size = 0, face = "bold"), # Bigger and bolder X axis title
    axis.title.y = element_text(size = 20, face = "bold"), # Bigger and bolder Y axis title
    axis.text.x = element_text(angle = 0, hjust = 0.5, size = 15), # Bigger X axis labels
    axis.text.y = element_text(size = 15), # Bigger Y axis labels
    plot.title = element_text(hjust = 0.5, size = 20), # Center and increase size of the title
    legend.title = element_text(size = 15), # Corrected legend title size
    legend.text = element_text(size = 12) # Corrected legend text size
  ) +
  labs(x = "Cell Type", y = "Average Expression", title = "Expression of Mmrn1 in LTHSC's and MPP's") +
  scale_y_continuous(limits = c(NA, 9)) + 
  annotate("segment", x = 3, xend = 4, y = 8.14285714, yend = 8.14285714, colour = "black", size = .5) + 
  annotate("segment", x = 1, xend = 3, y = 7.285714, yend = 7.285714, colour = "black", size = .5) +
  annotate("segment", x = 1, xend = 2, y = 7.5714, yend = 7.5714, colour = "black", size = .5) +  
  annotate("segment", x = 3, xend = 5, y = 7.85714286, yend = 7.85714286, colour = "black", size = .5) +  
  annotate("segment", x = 2, xend = 3, y = 7, yend = 7, colour = "black", size = .5) +   
  annotate("segment", x = 4, xend = 2, y = 8.42857143, yend = 8.42857143, colour = "black", size = .5) +
  annotate("segment", x = 5, xend = 2, y = 8.71428529, yend = 8.71428529, colour = "black", size = .5) +
  annotate("text", x = 3.5, y = 8.27, label = "NS", size = 2) +
  annotate("text", x = 1.5, y = 7.6, label = "*", size = 6) +
  annotate("text", x = 4, y = 7.85, label = "***", size = 6) +
  annotate("text", x = 2, y = 7.415, label = "NS", size = 2) +
  annotate("text", x = 2.5, y = 7.12, label = "NS", size = 2) +
  annotate("text", x = 1, y = 5.65, label = "5.149", size = 5) +
  annotate("text", x = 2, y = 4.2, label = "3.631", size = 5) +
  annotate("text", x = 3, y = 5.9, label = "4.971", size = 5) +
  annotate("text", x = 4, y = 2.6, label = "1.558", size = 5) +
  annotate("text", x = 5, y = 1.9, label = "1.329", size = 5) +
  annotate("text", x = 3, y = 8.55, label = "NS", size = 2) +
  annotate("text", x = 3.5, y = 8.71, label = "**", size = 6) 

Mmrn1_subpop_MPP_plot

# Save the plot
ggsave("figures/Mmrn1_subpop_MPP_plot.png", plot = Mmrn1_subpop_MPP_plot, width = 10, height = 6, dpi = 300)
```

We show a high level of Mmrn1 expression in the MPP1 population of cells which was interesting comparison but when we take the sub-population data and map that onto our 3D PCA we can easily see that the MPP1 population of cells overlaps with the LT.HSC population indicating they indeed have very similar gene expression @fig-3D_PCA_sub_population. Indeed the 3D PCA plot allowed for us to confrim that the now 6 celltypes too show this differntial gene expression but highlight more a gradual change in gene expression with some overlap between cell types hence this is the most likely explanation why there is much higher expression in MPP1 than MPP3.

```{r}
# here we are creating a 3D PCA like previosuly but with the sub-population data: 

# Prioritize cell types and remove "_broad" from cell_type
er_cell_types_long <- er_cell_types_long %>%
  mutate(cell_type = gsub("_broad", "", cell_type),
         priority_rank = case_when(
           grepl("LTHSC", cell_type) ~ 1,
           grepl("MPP[0-9]", cell_type) ~ 2,
           grepl("^MPP$", cell_type) ~ 3,
           grepl("STHSC", cell_type) ~ 4,
           TRUE ~ 5
         )) %>%
  arrange(cell, priority_rank) %>%
  group_by(cell) %>%
  slice(1) %>%
  ungroup() %>%
  select(-priority_rank)

# Prepare a mapping from 'cell' to 'cell_type' while retaining numeric identifier
er_cell_types_long$numeric_id <- gsub("\\D", "", er_cell_types_long$cell)
er_cell_types_long$original_prefix <- gsub("_\\d+$", "", er_cell_types_long$cell)
er_cell_types_long$new_id <- paste(er_cell_types_long$cell_type, er_cell_types_long$numeric_id, sep = "_")

# Create a mapping dictionary
id_mapping <- setNames(er_cell_types_long$new_id, er_cell_types_long$cell)

# Check for duplicate entries in the 'cell' column
if(anyDuplicated(er_cell_types_long$cell)) {
  stop("Duplicate 'cell' entries found in 'er_cell_types_long'. Cannot create a unique mapping.")
}

# Filter combined_data to include only columns present in er_cell_types_long$cell
combined_data_PCA <- combined_data[, names(combined_data) %in% er_cell_types_long$cell]

# Use id_mapping to rename columns in combined_data
colnames(combined_data_PCA) <- sapply(colnames(combined_data_PCA), function(col_name) {
  if(col_name %in% names(id_mapping)) {
    return(id_mapping[col_name])
  } else {
    return(NA) # Prepare to mark for removal if no mapping found
  }
})


# Transpose combined_data for PCA analysis
combined_data_t <- t(combined_data_PCA)

normalized_data <- scale(combined_data_t)

pca_result <- prcomp(normalized_data, scale. = TRUE)

pca_data <- as.data.frame(pca_result$x)

# Create a mapping of new_id to cell_type
cell_type_mapping <- setNames(er_cell_types_long$cell_type, er_cell_types_long$new_id)

# Use the row names of pca_data to map each row to its cell type
pca_data$cell_type <- cell_type_mapping[rownames(pca_data)]



# This is a precautionary step to filter out "Undefined" and NA cell types
undefined_cells <- pca_data$cell_type %in% c("Undefined", NA)

# Additionally, check for any cell_type not present in er_cell_types_long
valid_cell_types <- unique(er_cell_types_long$cell_type)
undefined_cells <- undefined_cells | !pca_data$cell_type %in% valid_cell_types

# Here we are remvoing any undefined cells from pca_data
pca_data <- pca_data[!undefined_cells, ]



# Assign a neutral color for baseline expression to all cells
pca_data$Color <- 'grey'  # Neutral color representing baseline expression

cell_type_colors <- c('CMP' = 'yellow',
                  'GMP' = 'darkgreen',
                  'LMPP' = 'blue',
                  'LTHSC' = 'green',
                  'MEP' = 'orange',
                  'MPP' = 'red',
                  'MPP1' = 'deeppink',
                  'MPP2' = 'pink',
                  'MPP3' = 'purple')

# Prepare the initial 3D PCA plot with all cells in grey to represent baseline expression
PCA_sub_population <- plot_ly(data = pca_data, x = ~PC1, y = ~PC2, z = ~PC3, type = 'scatter3d', mode = 'markers',
                                  marker = list(color = ~Color, size = 4, opacity = 0.5),  # Use the baseline color
                                  name = "Baseline Expression") %>%
  layout(title = "3D PCA Plot Highlighting Cell Types",
         scene = list(xaxis = list(title = "PC1"),
                      yaxis = list(title = "PC2"),
                      zaxis = list(title = "PC3")),
         legend = list(title = list(text = 'Cell Types'), orientation = "h"))

# Loop over each cell type and overlay their specific colors
for(cell_type in names(cell_type_colors)) {
  cells_of_type <- pca_data$cell_type == cell_type
  PCA_sub_population <- PCA_sub_population %>%
    add_trace(data = pca_data[cells_of_type, ], x = ~PC1, y = ~PC2, z = ~PC3,
              type = 'scatter3d', mode = 'markers',
              marker = list(color = cell_type_colors[cell_type], size = 4, opacity = 0.8),
              name = cell_type)
}

```

```{r}
#| label: fig-3D_PCA_sub_population
#| fig-cap: "3D PCA analysis showing difference in gene expression between sub population cell types. Sub population cell types defined using flow cytometry markers using broad gating and identified retrospectively by using index sorting data. Data analysis was conducted in R (R Core Team 2023) with plotly and tidyverse packages (Sievert et al. 2020; Wickham et al. 2019)."

# Display the plot
PCA_sub_population <- PCA_sub_population %>%
  layout(autosize = F, # Adjust size as needed
         legend = list(orientation = "v",  font = list(size = 18)))


PCA_sub_population

#save as a HTML   
htmlwidgets::saveWidget(PCA_sub_population, "figures/HTML_files/PCA_sub_population", selfcontained = TRUE)
```

To understand more the sub population data we performed hierarchical clustering to explore the intrinsic groupings within the data based on gene expression pattern, like that seen in @fig-heatmap-3-celltypes-clustering, but with our new cell type definitions applied @fig-heatmap-subpopulation-clustering. We again utilized Ward's method for both column and row clustering and as previously We did this on a subset of data by taking the top 50 differentially expressed genes determined from our differential expression analysis (Table 1), as it allowed for better visualisation, ensuring that the cells arranged into 4 clusters which allowed easy determination of how the different cell types clustered. The clustering differed from that in @fig-heatmap-subpopulation-clustering there were more cell types clustering together. However, we still saw cell types cluster based on there stemness and most interesting most of the LT.HSCs clustered with the MPP and LMPPs which can be classed as more differentiated than the other population of cells. one draw back to this analysis is the fact there were very few cells of the MPP1, MPP2 and MPP3 population so they are very difficult to see, so we altered the data set to make all the MPP populations one colour to be easy to visualise.

```{r}
# here we are generating a heatmap and performing heirarchical clustering. This uses the same method as previous code above but with the sub-population definitions applied:

# Load individual datasets again with the ensembl_gene_ids being the the row names 
prog <- read.csv("data_raw/surfaceome_Prog.csv", row.names = 1)
hspc <- read.csv("data_raw/surfaceome_hspc.csv", row.names = 1)
lthsc <- read.csv("data_raw/surfaceome_lthsc.csv", row.names = 1)


# Combine the datasets into one matrix
# Assuming cells are in columns and genes in rows
combined_data <- cbind(prog, hspc, lthsc)

# Function to prioritize cell types
prioritize_cell_type <- function(cell_type) {
  # Assign priority rank, explicitly ignore _broad cells by assigning NULL
  if(grepl("_broad", cell_type)) {
    return(NA)  # Assign NA to _broad cells to filter them out later
  } else {
    return(case_when(
      grepl("LTHSC$", cell_type) ~ 1,
      grepl("^MPP$", cell_type) ~ 2,
      grepl("MPP[0-9]$", cell_type) ~ 3,
      grepl("STHSC$", cell_type) ~ 4,
      TRUE ~ 5  # Default priority for unspecified types
    ))
  }
}

# Assuming er_cell_types_long_prioritised is your dataframe and new_id contains the IDs to be made unique
make_unique_new_id <- function(df) {
  # Create a dataframe to track the occurrence of each new_id
  occurrence_df <- df %>%
    group_by(new_id) %>%
    mutate(occurrence = row_number()) %>%
    ungroup()
  
  # For each new_id, if it's the first occurrence, keep it as is. 
  # If it's a subsequent occurrence, append a suffix starting from .1
  occurrence_df$new_id <- ifelse(occurrence_df$occurrence == 1, 
                                 occurrence_df$new_id, 
                                 paste0(occurrence_df$new_id, ".", occurrence_df$occurrence - 1))
  
  # Drop the temporary 'occurrence' column
  occurrence_df <- select(occurrence_df, -occurrence)
  
  return(occurrence_df)
}


# Apply prioritization logic and filter out _broad cells
er_cell_types_long_prioritised <- er_cell_types_long %>%
  mutate(priority_rank = sapply(cell_type, prioritize_cell_type)) %>%
  filter(!is.na(priority_rank)) %>%  # Filter out _broad cells
  arrange(cell, priority_rank, cell_type) %>%
  group_by(cell) %>%
  slice(1) %>%
  ungroup() %>%
  select(-priority_rank)  # Remove the priority rank column after sorting

# Apply the function to your dataframe
er_cell_types_long_prioritised <- make_unique_new_id(er_cell_types_long_prioritised)

# Update column names in combined_data based on the mapping
mapping <- setNames(er_cell_types_long$new_id, er_cell_types_long$cell)

# Update column names in combined_data
new_colnames <- sapply(colnames(combined_data), function(col_name) {
  if(col_name %in% names(mapping)) {
    return(mapping[col_name])
  } else {
    return(col_name)
  }
})

colnames(combined_data) <- new_colnames


# Ensure 'cell' column in er_cell_types_long is unique for accurate mapping
if(!anyDuplicated(er_cell_types_long$cell)) {
  # Create a mapping of original cell names to new cell_type identifiers
  cell_to_new_id_map <- setNames(er_cell_types_long$cell_type, er_cell_types_long$cell)
  
  # Generate new column names for combined_data by looking up each original column name in the map
  new_colnames <- sapply(colnames(combined_data), function(col_name) {
    # Extract the cell name prefix (e.g., "Prog_001") from the combined column name
    cell_name_prefix <- sub("^(Prog|HSPC|LTHSC)_", "\\1_", col_name)
    # Lookup the new cell_type identifier using the cell name prefix
    if(cell_name_prefix %in% names(cell_to_new_id_map)) {
      # Return the new identifier with original numeric suffix retained
      return(paste(cell_to_new_id_map[cell_name_prefix], sub(".*_(\\d+)$", "\\1", col_name), sep = "_"))
    } else {
      # If no mapping found, return the original column name
      return(col_name)
    }
  })
  
  # Update column names in combined_data
  colnames(combined_data) <- new_colnames
} else {
  stop("Duplicate 'cell' entries found in 'er_cell_types_long'. Cannot create a unique mapping.")
}


# Remove columns with names starting with "Prog_"
combined_data <- combined_data[, !grepl("^Prog_", colnames(combined_data))]

# Filter combined data for the specified ensembl_gene_id
# Extract the ensembl_gene_id column and create the vector
gene_names <- head(top_differentially_expressed_genes_no_duplicates$external_gene_name, 50)

# Retrieve Ensembl gene IDs based on the external gene names
genes_ensembl_ids <- getBM(attributes = c("external_gene_name", "ensembl_gene_id"),
                    filters = "external_gene_name",
                    values = gene_names,
                    mart = ensembl)
# create a vector for the ensembl_gene_ids
top_genes <- genes_ensembl_ids$ensembl_gene_id 

#filter the data for just the top genes 
combined_data_filtered <- combined_data[top_genes, ]

# Perform hierarchical clustering with complete linkage method for rows
hc_rows <- hclust(dist(combined_data_filtered, method = "euclidean"), method = "ward.D2")

# Perform hierarchical clustering with complete linkage method for columns
hc_cols <- hclust(dist(t(combined_data_filtered), method = "euclidean"), method = "ward.D2")

# Specify the number of clusters you want to cut the dendrogram into
num_clusters <- 4

# Cut the dendrogram to obtain cluster labels for rows and columns
clusters_rows <- cutree(hc_rows, k = num_clusters)
cluster_cols <- cutree(hc_cols, k = num_clusters)

# Get the order of rows and columns based on clustering
order_rows <- order.dendrogram(as.dendrogram(hc_rows))
order_cols <- order.dendrogram(as.dendrogram(hc_cols))

# Reorder the combined_data based on the clustering
combined_data_reordered <- combined_data_filtered[order_rows, order_cols]

# IMPORTANT: Reorder 'cluster_cols' to match the new order of columns in 'combined_data_reordered'
reordered_cluster_cols <- cluster_cols[order_cols]

# Now create annotation_data using the reordered cluster assignments
annotation_data <- data.frame(
  Cell = colnames(combined_data_reordered),  # Use reordered column names
  Cluster = reordered_cluster_cols           # Use reordered cluster assignments
)

# Create CellType column by removing anything after "_" in the cell names
annotation_data$CellType <- sub("_.*", "", annotation_data$Cell)

# Define custom colors for the clusters
cluster_colours <- c("purple", "cyan", "orange", "deeppink")  # Example custom colors

CellType_colours <- c('CMP' = 'yellow',
                  'GMP' = 'darkgreen',
                  'LMPP' = 'blue',
                  'LTHSC' = 'green',
                  'MEP' = 'orange',
                  'MPP' = 'red')

old_CellType_colours <- c('LT.HSC' = 'green',
                  'HSPC' = 'red',
                  'Prog' = 'blue')

# some cells didnt map correctly or didt have a sub-population definition so we are jusr removing them here 

# Remove rows with "HSPC" in the CellType column
annotation_data <- subset(annotation_data, CellType != "HSPC")

# even though the code above specificed for cells to be named generic MPP over MPP[1-3], however i was still noticing MPP[1-3] in the data set. This is an issue as there are too few cells with the MPP[0-3] definition to be able to be seen so we want all MPPs to be defined under one umbrella: 

# Replace "MPP1" with "MPP" in the CellType column of annotation_data
annotation_data$CellType <- gsub("MPP1", "MPP", annotation_data$CellType)


# Replace "MPP1" with "MPP" in the CellType column of annotation_data
annotation_data$CellType <- gsub("MPP2", "MPP", annotation_data$CellType)


# Replace "MPP1" with "MPP" in the CellType column of annotation_data
annotation_data$CellType <- gsub("MPP3", "MPP", annotation_data$CellType)

# Sort annotation_data by Cluster and then by CellType within each Cluster
annotation_data_sorted <- annotation_data %>%
  arrange(Cluster, CellType, Cell)

# Use the sorted annotation_data to define the new column order for combined_data_reordered
new_col_order <- match(annotation_data_sorted$Cell, colnames(combined_data_reordered))

# Apply this new column order to combined_data_reordered
combined_data_final <- combined_data_reordered[, new_col_order]

annotation_data_sorted <- subset(annotation_data_sorted, select = -c(Cell))


# Loop over each row name in combined_data_final
for (i in seq_along(rownames(combined_data_final))) {
    # Find the matching gene name for the current Ensembl ID
    matched_gene_name <- genes_ensembl_ids$external_gene_name[match(rownames(combined_data_final)[i], genes_ensembl_ids$ensembl_gene_id)]
    
    # Update the row name if a match is found
    if (!is.na(matched_gene_name)) {
        rownames(combined_data_final)[i] <- matched_gene_name
    }
    # If no match is found, do nothing, leaving the Ensembl ID as the row name
}

# Ensure annotation_data_sorted has a column for row names
annotation_data_sorted <- annotation_data_sorted %>%
  rownames_to_column("row_names")

# Join the data frames based on the new_id column and row_names
annotation_data_sorted <- annotation_data_sorted %>%
  left_join(er_cell_types_long_prioritised, by = c("row_names" = "new_id")) %>%
  # Create the 'old_celltype' column from 'original_prefix'
  mutate(old_CellType = original_prefix) %>%
  # Now, choose to keep all original columns from annotation_data_sorted plus the new old_celltype column
  select(-original_prefix, everything(), old_CellType)


# Set the first column as row names
row.names(annotation_data_sorted) <- annotation_data_sorted[[1]]


annotation_data_sorted <- subset(annotation_data_sorted, select = -c(cell, cell_type, numeric_id, original_prefix, row_names))
```

```{r}
#| label: fig-heatmap-subpopulation-clustering
#| fig.cap: "Heatmap showing gene expression of the top 50 differentially expressed genes in all cells with the sub-population definitions applied. Each cell in the heatmap represents the expression level of a gene in a specific cell type. gene expression is displayed on a log2 scale from blue to red (low to high). All 1654 cells are visualised along the X axis and the top 50 differentially expressed genes are shown on the Y axis, as calculated using a statistical model which finds the summary.logFC. Both the genes and cells were clustered using the ward method. The genes were clustered with no supervision whereas the cells were arranged into four clusters for better visual patterns in their gene expression. Data analysis as conducted in R (R Core Team 2023) with biomaRt, pheatmap and tidyverse packages (Durinck et al. 2009; Kolde et al. 2019; Wickham et al. 2019)"
#| fig.align: "left" 
#| fig.height: 5 
# Note the clustering is set to FALSE in the code below becuase we have previously ordered the rows and columns in our data set to be in the clusters. 
heatmap_subpopulation_clustering <- pheatmap(
  combined_data_final, cellheight = 5.7,
  cluster_rows = FALSE,   # Cluster rows
  cluster_cols = FALSE,  # Do not cluster columns
  show_rownames = TRUE,  # Show row names
  show_colnames = FALSE,  # Do not show column names
  fontsize_row = 6,
  fontsize_col = 6,
  angle_col = 45,
  color = colorRampPalette(c("blue", "white", "red"))(100),
  legend = TRUE,
  annotation_col = annotation_data_sorted,
  treeheight_row = 5,     # Hide dendrogram lines for rows
  treeheight_col = 5,     # Hide dendrogram lines for columns
  annotation_colors = list(CellType = CellType_colours, Cluster = cluster_colours,old_CellType = old_CellType_colours)  # Specify custom colors for the cluster annotations
)

# Save the plot
ggsave("figures/heatmap_subpopulation_clustering.png", plot = heatmap_subpopulation_clustering, width = 10, height = 6, dpi = 300)
```

Interestingly, the heatmap clustered Mmrn1 in the same gene cluster as Procr again indicating they have very similar gene expression. Procr is used as a marker primarly to extract ESLAM cells. To analyse this relationship further we compared expression levels of CD150, Procr and Mmrn1 across sub-population cell types including ESLAM cells @fig-ESLAM-mmrn1-plot. We found that expression of Procr and Mmrn1 followed a very similar pattern and expression was non-significantly different in all cells but LMPPs and MEPs. Expression of CD150 doesn't fit the same trend as Procr and mmrn1 and only is non-significantly different from both in CMPs and GMPs. Most notably expression of CD150 is significantly lower in MPPs and LT.HSCs than that of Procr and mmrn1. However its expression in LT.HSCs compared with MPPs is significantly higher ( P = 0.00000471). Most interestingly, Mmrn1 expression was extremely high in the ESLAM cells like that of Procr. Showing further the overlap of Mmrn1 expression to that of Procr and more specifically within cells used routinely for HSC purification.

```{r}
#| include: false
#Here we are looking at Mmrn1, Procr and CD150 average expression: 

# Load individual datasets again with the ensembl_gene_ids being the the row names 
prog <- read.csv("data_raw/surfaceome_Prog.csv", row.names = 1)
hspc <- read.csv("data_raw/surfaceome_hspc.csv", row.names = 1)
lthsc <- read.csv("data_raw/surfaceome_lthsc.csv", row.names = 1)


# Combine the datasets into one matrix
# Assuming cells are in columns and genes in rows
combined_data <- cbind(prog, hspc, lthsc)

er_cell_types_long <- pivot_longer(er_cell_types, cols = -cell, names_to = "cell_type", values_to = "value") %>%
  filter(value == 1) %>%
  select(-value)

prioritize_cell_type <- function(cell_type) {
  priority_rank <- case_when(
    grepl("ESLAM", cell_type) ~ 1,  # Highest priority for ESLAM cells
    grepl("LTHSC", cell_type) & !grepl("_broad", cell_type) ~ 2,
    grepl("^MPP$", cell_type) ~ 3,
    grepl("MPP[0-9]", cell_type) ~ 4,
    grepl("STHSC", cell_type) & !grepl("_broad", cell_type) ~ 5,
    TRUE ~ 6  # Default priority for unspecified types or broad types
  )
  return(priority_rank)
}


# Apply prioritization logic
er_cell_types_long_ESLAM <- er_cell_types_long %>%
  mutate(priority_rank = sapply(cell_type, prioritize_cell_type)) %>%
  arrange(cell, priority_rank, cell_type) %>%
  group_by(cell) %>%
  slice(1) %>%
  ungroup() %>%
  select(-priority_rank)

er_cell_types_long_ESLAM <- er_cell_types_long_ESLAM %>%
  mutate(new_id = paste(cell_type, sub(".*_(\\d+)$", "\\1", cell), sep = "_"))


# Update column names in combined_data based on the mapping
mapping <- setNames(er_cell_types_long_ESLAM$new_id, er_cell_types_long_ESLAM$cell)

# Update column names in combined_data
new_colnames <- sapply(colnames(combined_data), function(col_name) {
  if(col_name %in% names(mapping)) {
    return(mapping[col_name])
  } else {
    return(col_name)
  }
})

colnames(combined_data) <- new_colnames

#Here we are looking at Mmrn1, Procr and CD150 average expression: 

# Filter for the specific genes using the Ensembl gene IDs
gene_ids_of_interest <- c('ENSMUSG00000054641', 'ENSMUSG00000027611', 'ENSMUSG00000015316')

# Filter rows based on these gene IDs
gene_expression <- combined_data[rownames(combined_data) %in% gene_ids_of_interest, ]

# Transpose the filtered data
gene_expression <- t(gene_expression)

gene_expression <- as.data.frame(gene_expression)

gene_expression$cell <- rownames(gene_expression)

gene_expression$new_cell <- sub("_\\d+$", "", gene_expression$cell)

# Rename columns using dplyr::rename to avoid any naming conflict
gene_expression <- gene_expression %>%
  dplyr::rename(Mmrn1 = ENSMUSG00000054641, EPCR = ENSMUSG00000027611, CD150 = ENSMUSG00000015316)


# Assuming 'df' has columns 'cell_type', 'Mmrn1', and 'EPCR'
# First, ensure 'cell_type' is correctly filtered and not including '_broad', there should not be any in there this is just ensuring there isnt. 
gene_expression <- gene_expression %>%
  filter(new_cell %in% c("LTHSC", "ESLAM", "MEP", "CMP", "GMP", "LMPP", "MPP"),
         !grepl("_broad", new_cell))

# For accurate SEM calculation, ensure there's a grouping step before summarise
# Here, we pivot longer first to make 'Gene' a column, then calculate mean and SEM
gene_expression_SEM <- gene_expression %>%
  pivot_longer(cols = c("Mmrn1", "EPCR", "CD150"), names_to = "Gene", values_to = "Expression") %>%
  group_by(new_cell, Gene) %>%
  summarise(
    Average_Expression = mean(Expression, na.rm = TRUE),
    SEM = sd(Expression, na.rm = TRUE) / sqrt(n()),
    .groups = 'drop'
  )


gene_expression_SEM$Gene <- factor(gene_expression_SEM$Gene, levels = c("Mmrn1", "EPCR", "CD150"))

# Define colors for each gene
gene_colors <- c(Mmrn1 = "#E41A1C", EPCR = "#377EB8", CD150 = "#984EA3")


```

```{r}
#| include: false
# Assuming filtered_df is your dataframe and it has columns for cell types and gene expressions
# Define the cell types shown in your graph
selected_cell_types <- c("CMP", "ESLAM", "GMP", "LMPP", "LTHSC", "MEP", "MPP")

# Define the genes to compare
genes <- c("Mmrn1", "EPCR", "CD150")

# Initialize an empty list to store the results
t_test_results <- list()

# Loop through each selected cell type
for (subtype in selected_cell_types) {
  # Subset the data for the current cell type
  subset_data <- gene_expression %>% filter(new_cell == subtype)
  
  # Perform pairwise t-tests for each gene combination
  for (i in 1:(length(genes)-1)) {
    for (j in (i+1):length(genes)) {
      # Perform t-test for the gene pair
      t_test_result <- t.test(subset_data[[genes[i]]], subset_data[[genes[j]]])
      
      # Create a label for this test
      test_label <- paste(subtype, genes[i], "vs", genes[j], sep = " - ")
      
      # Store the formatted p-value in the list
      t_test_results[[test_label]] <- formatC(t_test_result$p.value, format = "f", digits = 10)
    }
  }
}

# Print the formatted p-values for each comparison
cat("Pairwise T-Test P-values:\n")
for (test_label in names(t_test_results)) {
  cat(test_label, "P-value:", t_test_results[[test_label]], "\n")
}



# T.test for LT.HSC and MPP -----------------------------------------------

# Assuming 'df' contains the dataset with columns 'cell_type', 'Mmrn1', 'EPCR', and 'CD150'

# Filter the data for MPPs and LT.HSCs
mpps_data <- gene_expression %>% filter(new_cell == "MPP")
lt_hscs_data <- gene_expression %>% filter(new_cell == "LTHSC")

# Perform t-test for CD150 expression in MPPs vs LT.HSCs
t_test_result <- t.test(mpps_data$CD150, lt_hscs_data$CD150)

# Print the result
cat("T-Test Result for CD150 expression in MPPs vs LT.HSCs:\n")
cat("P-value:", formatC(t_test_result$p.value, format = "f", digits = 20), "\n")
```

```{r}
#| label: fig-ESLAM-mmrn1-plot
#| fig.cap: "Comparison of average expression of Mmrn1, Procr and CD150 genes using the same single cell RNA sequencing data seen in figure 10. The expression of all 3 genes was compared against the 7 cell types using retrospectively using index-sorting data provided by Nesterowa et al. The addition of ESLAM cells was incorporated by redefining cells within the original data set using Nesterowa et al’s matrix of cell type information which defines further subpopulations of cells based on the flow cytometry markers. Note these cells were defined by EPCR+CD48–CD150+ because CD45 was not available in the index data. Data analysis as conducted in R (R Core Team 2023) with tidyverse packages (Wickham et al. 2019)"
#| fig.align: "left" 
#| fig.width: 10 
#| fig.height: 8

# Define the desired order for cell types
cell_type_order <- c("CMP", "ESLAM", "GMP", "LMPP", "LTHSC", "MEP", "MPP")

# Convert 'new_cell' to a factor with levels defined by 'cell_type_order'
gene_expression$new_cell <- factor(gene_expression$new_cell, levels = cell_type_order)

# Now, plotting with error bars
ESLAM_mmrn1_plot <- ggplot(gene_expression_SEM, aes(x = new_cell, y = Average_Expression, fill = Gene)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.5), width = 0.5) +
  geom_errorbar(aes(ymin = Average_Expression - SEM, ymax = Average_Expression + SEM), 
                width = 0.2, position = position_dodge(width = 0.5)) +
  scale_fill_manual(values = gene_colors, name = "Gene") +
  labs(title = "Average Gene Expression of Procr, CD150 and Mmrn1",
       x = "", y = "Average Expression") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, size = 25),
        axis.title = element_text(size = 25),
        axis.text = element_text(size = 20),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        axis.line = element_line(color = "black"),
        legend.position = "side") + 
  annotate("segment", x = 0.75, xend = 1, y = 1.3, yend = 1.3, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 0.75, xend = 0.75, y = 1.3, yend = 1.2, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 1, xend = 1, y = 1.3, yend = 1.2, colour = "black", linewidth = 0.8) +
  annotate("text", x = 0.875, y = 1.43, label = "NS", size = 4.5) +
  annotate("segment", x = 1, xend = 1.25, y = 1.6, yend = 1.6, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 1, xend = 1, y = 1.6, yend = 1.5, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 1.25, xend = 1.25, y = 1.6, yend = 1.5, colour = "black", linewidth = 0.8) +
  annotate("text", x = 1.125, y = 1.73, label = "NS", size = 4.5) +
  annotate("segment", x = 0.75, xend = 1.25, y = 1.9, yend = 1.9, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 0.75, xend = 0.75, y = 1.9, yend = 1.8, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 1.25, xend = 1.25, y = 1.9, yend = 1.8, colour = "black", linewidth = 0.8) +
  annotate("text", x = 1, y = 2.03, label = "NS", size = 4.5) +
  annotate("segment", x = 1.75, xend = 2, y = 7.8, yend = 7.8, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 1.75, xend = 1.75, y = 7.8, yend = 7.7, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 2, xend = 2, y = 7.8, yend = 7.7, colour = "black", linewidth = 0.8) +
  annotate("text", x = 1.875, y = 7.93, label = "NS", size = 4.5) +
  annotate("segment", x = 2, xend = 2.25, y = 8.1, yend = 8.1, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 2, xend = 2, y = 8.1, yend = 8, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 2.25, xend = 2.25, y = 8.1, yend = 8, colour = "black", linewidth = 0.8) +
  annotate("text", x = 2.125, y = 8.1, label = "****", size = 8) +
  annotate("segment", x = 1.75, xend = 2.25, y = 8.4, yend = 8.4, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 1.75, xend = 1.75, y = 8.4, yend = 8.3, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 2.25, xend = 2.25, y = 8.4, yend = 8.3, colour = "black", linewidth = 0.8) +
  annotate("text", x = 2, y = 8.4, label = "****", size = 8) +
  annotate("segment", x = 2.75, xend = 3, y = 1.1, yend = 1.1, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 2.75, xend = 2.75, y = 1.1, yend = 1, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 3, xend = 3, y = 1.1, yend = 1, colour = "black", linewidth = 0.8) +
  annotate("text", x = 2.875, y = 1.23, label = "NS", size = 4.5) +
  annotate("segment", x = 3, xend = 3.25, y = 1.4, yend = 1.4, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 3, xend = 3, y = 1.4, yend = 1.3, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 3.25, xend = 3.25, y = 1.4, yend = 1.3, colour = "black", linewidth = 0.8) +
  annotate("text", x = 3.125, y = 1.53, label = "NS", size = 4.5) +
  annotate("segment", x = 2.75, xend = 3.25, y = 1.7, yend = 1.7, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 2.75, xend = 2.75, y = 1.7, yend = 1.6, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 3.25, xend = 3.25, y = 1.7, yend = 1.6, colour = "black", linewidth = 0.8) +
  annotate("text", x = 3, y = 1.83, label = "NS", size = 4.5) +
  annotate("segment", x = 3.75, xend = 4, y = 2.6, yend = 2.6, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 3.75, xend = 3.75, y = 2.6, yend = 2.5, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 4, xend = 4, y = 2.6, yend = 2.5, colour = "black", linewidth = 0.8) +
  annotate("text", x = 3.875, y = 2.6, label = "*", size = 8) +
  annotate("segment", x = 4, xend = 4.25, y = 2.9, yend = 2.9, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 4, xend = 4, y = 2.9, yend = 2.8, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 4.25, xend = 4.25, y = 2.9, yend = 2.8, colour = "black", linewidth = 0.8) +
  annotate("text", x = 4.125, y = 2.9, label = "****", size = 8) +
  annotate("segment", x = 3.75, xend = 4.25, y = 3.2, yend = 3.2, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 3.75, xend = 3.75, y = 3.2, yend = 3.1, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 4.25, xend = 4.25, y = 3.2, yend = 3.1, colour = "black", linewidth = 0.8) +
  annotate("text", x = 4, y = 3.2, label = "****", size = 8) +
  annotate("segment", x = 4.75, xend = 5, y = 6, yend = 6, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 4.75, xend = 4.75, y = 6, yend = 5.9, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 5, xend = 5, y = 6, yend = 5.9, colour = "black", linewidth = 0.8) +
  annotate("text", x = 4.875, y = 6.13, label = "NS", size = 4.5) +
  annotate("segment", x = 5, xend = 5.25, y = 6.3, yend = 6.3, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 5, xend = 5, y = 6.3, yend = 6.2, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 5.25, xend = 5.25, y = 6.3, yend = 6.2, colour = "black", linewidth = 0.8) +
  annotate("text", x = 5.125, y = 6.3, label = "****", size = 8) +
  annotate("segment", x = 4.75, xend = 5.25, y = 6.6, yend = 6.6, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 4.75, xend = 4.75, y = 6.6, yend = 6.5, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 5.25, xend = 5.25, y = 6.6, yend = 6.5, colour = "black", linewidth = 0.8) +
  annotate("text", x = 5, y = 6.6, label = "****", size = 8) +
  annotate("segment", x = 6, xend = 6.25, y = 2, yend = 2, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 6, xend = 6, y = 2, yend = 1.9, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 6.25, xend = 6.25, y = 2, yend = 1.9, colour = "black", linewidth = 0.8) +
  annotate("text", x = 5.875, y = 1.83, label = "NS", size = 4.5) +
  annotate("segment", x = 5.75, xend = 6, y = 1.7, yend = 1.7, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 6, xend = 6, y = 1.7, yend = 1.6, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 5.75, xend = 5.75, y = 1.7, yend = 1.6, colour = "black", linewidth = 0.8) +
  annotate("text", x = 6.125, y = 2, label = "****", size = 8) +
  annotate("segment", x = 5.75, xend = 6.25, y = 2.4, yend = 2.4, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 5.75, xend = 5.75, y = 2.4, yend = 2.3, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 6.25, xend = 6.25, y = 2.4, yend = 2.3, colour = "black", linewidth = 0.8) +
  annotate("text", x = 6, y = 2.4, label = "***", size = 8) +
  annotate("segment", x = 6.75, xend = 7, y = 3.7, yend = 3.7, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 6.75, xend = 6.75, y = 3.7, yend = 3.6, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 7, xend = 7, y = 3.7, yend = 3.6, colour = "black", linewidth = 0.8) +
  annotate("text", x = 6.875, y = 3.83, label = "NS", size = 4.5) +
  annotate("segment", x = 7, xend = 7.25, y = 4, yend = 4, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 7, xend = 7, y = 4, yend = 3.9, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 7.25, xend = 7.25, y = 4, yend = 3.9, colour = "black", linewidth = 0.8) +
  annotate("text", x = 7.125, y = 4, label = "****", size = 8) +
  annotate("segment", x = 6.75, xend = 7.25, y = 4.3, yend = 4.3, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 6.75, xend = 6.75, y = 4.3, yend = 4.2, colour = "black", linewidth = 0.8) +
  annotate("segment", x = 7.25, xend = 7.25, y = 4.3, yend = 4.2, colour = "black", linewidth = 0.8) +
  annotate("text", x = 7, y = 4.3, label = "****", size = 8) 
  
ESLAM_mmrn1_plot

# Save the plot
ggsave("figures/ESLAM_mmrn1_plot.png", plot = ESLAM_mmrn1_plot, width = 10, height = 6, dpi = 300)
```

We have shown RNA-seq analysis of haemopoietic stem and progenitor populations revealed mmrn1 to be highly and specifically expressed in the LT.HSC and MPP population when compared to progenitors. We attempted to confirm these observations by qPCR analysis, where we analysed cDNA for LT.HSC, MPP and progenitor cells, sorted by ......, from 7 mice and found Mmrn1 expression is high in LT.HSC and MPP cells when compared to progenitors @fig-qPCR-plot.

```{r}
# first i am loading in my raw data files 
# Load our qPCR data from Excel
qPCR_raw <- read_excel("qPCR_data/qPCR_raw_data.xlsx")

#i am writing as a html to be uploaded to github so a URL can be made so the reader of the html output can see the raw data files 

# Create interactive DT tables for each dataset
dt_qPCR_raw <- datatable(qPCR_raw, options = list(pageLength = 10, searchHighlight = TRUE))

# Save the DT tables as HTML files
saveWidget(dt_qPCR_raw, "qPCR_data/HTML/qPCR_raw_data.html", selfcontained = TRUE)

# it comes up with a warning for the tables indicating they are too large but when inspecting them, the tables seem to be complete. For larger data sets one will likely not be able to use datatables. 

```

```{r}
#| include: false

# To perfrom statistical analysis we first filtered the data for PROG, LT.HSC, and MPP cell types
prog_data <- subset(qPCR_raw, cell_type %in% c("PROG4", "PROG2", "PROG7", "PROG3"))
lthsc_data <- subset(qPCR_raw, cell_type %in% c("LT.HSC11", "LT.HSC5", "LT.HSC6", "LT.HSC7", "LT.HSC12"))
mpp_data <- subset(qPCR_raw, cell_type %in% c("MPP6", "MPP7", "MPP11", "MPP12"))

# Perform t-tests between PROG and LT.HSC
t_test_prog_lthsc <- t.test(prog_data$Mmrn1_mean, lthsc_data$Mmrn1_mean)
print("T-test between PROG and LT.HSC:")
print(t_test_prog_lthsc)

# Perform t-tests between PROG and MPP
t_test_prog_mpp <- t.test(prog_data$Mmrn1_mean, mpp_data$Mmrn1_mean)
print("T-test between PROG and MPP:")
print(t_test_prog_mpp)

# Perform t-tests between LT.HSC and MPP
t_test_lthsc_mpp <- t.test(lthsc_data$Mmrn1_mean, mpp_data$Mmrn1_mean)
print("T-test between LT.HSC and MPP:")
print(t_test_lthsc_mpp)

# This is a function to group cell types
group_cell_types <- function(cell_type) {
  if(grepl("MPP", cell_type)) {
    return("MPP")
  } else if(grepl("PROG", cell_type)) {
    return("PROG")
  } else if(grepl("LT.HSC", cell_type)) {
    return("LT.HSC")
  } else {
    return(cell_type)
  }
}

# Apply grouping function to cell_type to get a new column, basically we are removing the numbers which specify which specifc cell, eg: MPP4 is now just MPP 
qPCR_raw$cell_type_grouped <- sapply(qPCR_raw$cell_type, group_cell_types)

# Calculate mean expression and standard error for each grouped cell type
qPCR_data_processed <- qPCR_raw %>%
  group_by(cell_type_grouped) %>%
  summarise(
    Mmrn1_expression = mean(Mmrn1_mean),
    SE = if(n() > 1) sd(Mmrn1_mean) / sqrt(n()) else NA_real_ # Only calculate SE for groups with more than 1 data point
  )

```

```{r}
#| label: fig-qPCR_plot
#| fig.cap: "Quantitative PCR analysis of Mmrn1 expression across the progenitor, MPP, and LT.HSC population. Results are representative of one experiment and shown as mean ± SEM. n = 4-5 mice. Data analysis was conducted in R (R Core Team 2023) with readxl and tidyverse packages (Wickham et al., 2023; Wickham et al., 2019)."
#| fig.align: left
#| fig.width: 10
#| fig.height: 8

# Defining the colours for each cell type 
custom_colors <- c("PROG" = "blue", "MPP" = "red", "LT.HSC" = "green")

# Create a bar plot with error bars
qPCR_plot <- ggplot(qPCR_data_processed, aes(x = cell_type_grouped, y = Mmrn1_expression, fill = cell_type_grouped)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  geom_errorbar(aes(ymin = Mmrn1_expression - SE, 
                    ymax = Mmrn1_expression + SE),
                position = position_dodge(width = 0.9), width = 0.25, size = 1) +
  labs(x = NULL, y = "Relative Abundance", fill = "CellType") + # Remove X axis title
  ggtitle("QPCR analysis of Mmrn1 Expression") +
  theme_minimal() +
  theme(
    axis.text = element_text(size = 20), # Increase axis text size
    axis.title = element_text(size = 25), # Increase axis title size
    panel.grid.major = element_blank(), # Remove major grid lines
    panel.grid.minor = element_blank(), # Remove minor grid lines
    axis.line = element_line(size = 1), # Make axis lines thicker
    plot.title = element_text(size = 30, hjust = 0.5), legend.text = element_text(size = 20), legend.title = element_text(size = 25),# Increase legend text size
    legend.key.size = unit(1, "cm"), # Center and increase title size
    plot.margin = margin(t = 0, r = 0, b = 30, l = 0, unit = "pt")
  ) + scale_fill_manual(values = custom_colors) +  ylim(0, 13) +
  annotate("text", x = 1, y = 6.82, label = "4.861", size = 8) +
  annotate("text", x = 2, y = 9.62, label = "5.266", size = 8) +
  annotate("text", x = 3, y = 2.22, label = "1.411", size = 8) +
  annotate("segment", x = 1, xend = 2, y = 10.4, yend = 10.4, colour = "black", size = 1) +
  annotate("segment", x = 1, xend = 1, y = 10.4, yend = 10.1, colour = "black", size = 1) +
  annotate("segment", x = 2, xend = 2, y = 10.4, yend = 10.1, colour = "black", size = 1) +
  annotate("segment", x = 2, xend = 2, y = 11.5, yend = 11.2, colour = "black", size = 1) +
  annotate("segment", x = 3, xend = 3, y = 11.5, yend = 11.2, colour = "black", size = 1) +
  annotate("segment", x = 2, xend = 3, y = 11.5, yend = 11.5, colour = "black", size = 1) +
  annotate("segment", x = 1, xend = 1, y = 12.6, yend = 12.3, colour = "black", size = 1) +
  annotate("segment", x = 3, xend = 3, y = 12.6, yend = 12.3, colour = "black", size = 1) +
  annotate("segment", x = 1, xend = 3, y = 12.6, yend = 12.6, colour = "black", size = 1) +
  annotate("text", x = 1.5, y = 10.75, label = "P = 0.929", size = 8) +
  annotate("text", x = 2.5, y = 11.85, label = "P = 0.4048", size = 8) +
  annotate("text", x = 2, y = 12.95, label = "P = 0.08899", size = 8) 

qPCR_plot

# Save the plot
ggsave("figures/qPCR_plot.png", plot = qPCR_plot, width = 10, height = 6, dpi = 300)
```

# discussion

to be completed
